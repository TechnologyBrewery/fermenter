package ${basePackage}.bizobj;

import java.io.Serializable;
import java.util.HashSet;
import java.util.Set;
import static java.lang.Math.floor;
import static java.lang.String.valueOf;

import javax.inject.Inject;
import javax.validation.constraints.Digits;
import javax.validation.constraints.DecimalMax;
import javax.validation.constraints.DecimalMin;
import javax.validation.constraints.Max;
import javax.validation.constraints.Min;
import javax.validation.constraints.NotNull;
import javax.validation.constraints.Pattern;
import javax.validation.constraints.Size;
import org.apache.commons.lang3.builder.ReflectionToStringBuilder;

#if ( $entity.isTransient() )
import org.bitbucket.fermenter.stout.bizobj.BaseSpringBO;
import org.bitbucket.fermenter.stout.bizobj.BusinessObject;
#else
import org.bitbucket.fermenter.stout.bizobj.BasePersistentSpringBO;
import org.bitbucket.fermenter.stout.bizobj.PersistentBusinessObject;
import org.bitbucket.fermenter.stout.messages.Message;
import org.bitbucket.fermenter.stout.messages.MessageFactory;
import org.bitbucket.fermenter.stout.messages.MessageManager;
import org.bitbucket.fermenter.stout.messages.Severity;
import org.bitbucket.fermenter.stout.util.MetamodelInstanceUtil;

import org.hibernate.annotations.Type;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.FetchType;
import javax.persistence.Id;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.JoinColumn;
import javax.persistence.MappedSuperclass;
import javax.persistence.OneToMany;
import javax.persistence.ManyToOne;
import javax.persistence.Transient;
import javax.persistence.criteria.CriteriaBuilder;
import javax.persistence.criteria.CriteriaQuery;
import javax.persistence.criteria.JoinType;
import javax.persistence.criteria.Predicate;
import javax.persistence.criteria.Root;
import javax.persistence.metamodel.PluralAttribute;

import org.springframework.data.jpa.domain.Specification;
import static org.springframework.data.jpa.domain.Specifications.where;
import org.springframework.data.jpa.repository.JpaRepository;
import org.springframework.data.domain.Example;
import org.springframework.data.domain.Page;
import org.springframework.data.domain.PageRequest;
import org.springframework.data.domain.Pageable;
import org.springframework.data.domain.Sort;

import org.hibernate.annotations.Type;

	#if (!$entity.isNonPersistentParentEntity())
import ${basePackage}.persist.${entity.name}Repository;
	#end
#end

#foreach ($import in $entity.imports )
import ${import};
#end

#foreach ($reference in $entity.references )
  #if ($reference.isExternal() )
import ${reference.importPrefix}.client.service.${reference.type}MaintenanceDelegate;
  #end
#end

#if ( !$entity.idFields.isEmpty() )
  #set ($idFieldJavaType = ${entity.idFields.values().iterator().next().javaType})
#else
  #set ($idFieldJavaType = 'String')
#end  
/**
 * Business object for the ${entity.name} application entity.
#if ($entity.documentation)
 * ${entity.documentation}
#end
 *
 * Generated Code - DO NOT MODIFY
 */
#if ( $entity.isTransient())
	#if ($entity.hasParent())
public abstract class ${entity.name}BaseBO extends ${entity.persistentEntityParentJavaType} implements BusinessObject<${entity.persistentEntityParentJavaType}> {
    #else    
public abstract class ${entity.name}BaseBO extends BaseSpringBO<${entity.name}BO> implements BusinessObject<${entity.name}BO> {
    #end
#elseif ( $entity.isNonPersistentParentEntity() )
@MappedSuperclass
public abstract class ${entity.name}BaseBO<PK extends Serializable, BO, JPA extends JpaRepository<BO, PK>> extends BasePersistentSpringBO<PK, BO, JPA> implements PersistentBusinessObject<PK, BO> {
#else 
@MappedSuperclass
public abstract class ${entity.name}BaseBO extends ${entity.persistentEntityParentJavaType}<${idFieldJavaType}, ${entity.name}BO, ${entity.name}Repository> implements PersistentBusinessObject<${idFieldJavaType}, ${entity.name}BO> {

	@Inject
	@Transient
	private ${entity.name}Repository repository;
	
	private static boolean hasCheckedTableMismatch;
#end

#foreach ( $idField in $entity.idFields.values() )
	#if ( !$entity.isTransient() )
	@Id
	#if ($idField.type == 'uuid')
  	@Type(type = "org.hibernate.type.UUIDCharType")
  	#end 
	#if ( $idField.hasGenerator() )
		#if ( $idField.generator == 'identity')
	@GeneratedValue(strategy=GenerationType.IDENTITY)	
		#else 
	@GeneratedValue
		#end
	#end
	@Column(name="${idField.column}")
	#end
	private ${idField.javaType}	${idField.name};
	
#end

#foreach ( $field in $entity.fields.values() )
  #if ( !$entity.isTransient() )
  #set ( $isRequired = $field.isRequired() )
	@Column(name="${field.column}" #if($isRequired), nullable=false#end #if($field.javaType == 'BigDecimal' && $field.hasScale()), scale=${field.scale}#end)
  #end
  #if ( $field.isRequired() )
	@NotNull
  #end
  #if ( $field.hasMinLength() || $field.hasMaxLength() && !$field.isEnumerationType())
  	@Size(#if($field.hasMinLength())min=${field.minLength}#if($field.hasMaxLength()),#end#end #if($field.hasMaxLength())max=${field.maxLength}#end)
  #end
  #if ( $field.hasMaxValue() )
  	#if ($field.javaType == 'BigDecimal')
  	@DecimalMax("${field.maxValue}")
  	#else
  	@Max(${field.maxValue})
  	#end
  #end
  	#if ($field.javaType == 'BigDecimal' && $field.hasScale())
    @Digits(integer= #if($field.hasMaxValue())
            $field.maxValue.split('\.')[0].length()
	#else Integer.MAX_VALUE
	#end, fraction=$field.scale)
  	#end
  #if ( $field.hasMinValue() )
  	#if ($field.javaType == 'BigDecimal')
  	@DecimalMin("${field.minValue}")
  	#else
  	@Min(${field.minValue})
  	#end
  #end
  #if ( $field.hasFormat() )
    @Pattern(regexp=${field.patterns})
  #end
  #if ($field.type == 'numeric_boolean')
  	@Type(type = "org.hibernate.type.NumericBooleanType")
  #end 
  #if ($field.type == 'uuid')
  	@Type(type = "org.hibernate.type.UUIDCharType")
  #end   
	private ${field.javaType} ${field.name};

#end

#if ( !$entity.isTransient() && !$entity.isNonPersistentParentEntity() )
    /**
     * While distasteful to leverage the name of a subclass, we know this to be 100% consistent w/in Stout and it
     * allows for checking to ensure that the table name, which *must* be specified in the leaf class from a JPA
     * perspective, matches the table name most recently specified in the metamodel instance for ${entity.name}.  In
     * some cases, this just results in a straightforward error.  In others, it can be a pain to track down, so this
     * compromise is justified as worth the labor/frustration savings.
     */
	protected ${entity.name}BaseBO() {
		if (!hasCheckedTableMismatch) {
	    	String leafClassName = "${basePackage}.bizobj.${entity.name}BO";
	    	MetamodelInstanceUtil.checkTableNameForMismatch(leafClassName, "${entity.table}");
	    	hasCheckedTableMismatch = true;
	    }
	}
#end


#if ( !$entity.idFields.isEmpty() )
  #set ($idField = ${entity.idFields.values().iterator().next()})
	
	#if ( !$entity.isTransient() )
	@Override
	public ${idField.javaType} getKey() {
		return ${idField.name}; 
	}
	
	@Override
	public void setKey(${idField.javaType} ${idField.name}) {
		set${idField.capitalizedName}(${idField.name});
	}
	#end
#end
	
#if ( !$entity.isTransient() && !$entity.isNonPersistentParentEntity() )
	#if (!$entity.relations.isEmpty())
  		#set ($idField = ${entity.idFields.values().iterator().next()})
	public static ${entity.name}BO findByPrimaryKey(${idFieldJavaType} key) {
		${entity.name}BO foundBO = ${entity.name}BO.findByPrimaryKey(key, false);
		if (foundBO != null) {
			foundBO.postFindByPrimaryKey();
		}
		return foundBO;
	}
	
	public static ${entity.name}BO findByPrimaryKey(${idFieldJavaType} key, boolean eagerFetchRelations) {
		${entity.name}BO foundBO = eagerFetchRelations ? getDefaultRepository().findOne(where(keyEquals(key)).and(eagerFetchRelations())) : getDefaultRepository().findOne(key);
		if (foundBO != null) {
			foundBO.postFindByPrimaryKey();
		}
		return foundBO;
	}
	#else
	public static ${entity.name}BO findByPrimaryKey(${idFieldJavaType} key) {
		${entity.name}BO foundBO = getDefaultRepository().findOne(key);
		if (foundBO != null) {
			foundBO.postFindByPrimaryKey();
		}
		return foundBO;
	}
	#end

	public static Page<${entity.name}BO> findByExample(${entity.name}BO probe, Integer page, Integer size, Sort sort) {
		Page<${entity.name}BO> result = null;
	    if(probe == null) {
			// default to find all if no probe is specified
	        probe = new ${entity.name}BO();
	    }
	    if(sort == null) {
            Message msg = MessageFactory.createMessage();
            msg.setKey("${entity.name}BO.findByExample.requiresSort" );
            msg.setSeverity(Severity.ERROR);
            msg.addProperty("When searching by example, a valid sort is required." );
            MessageManager.addMessage(msg);
        } else if(page == null) {
            Message pageMsg = MessageFactory.createMessage();
            pageMsg.setKey("${entity.name}BO.findByExample.requiresPage");
            pageMsg.setSeverity(Severity.ERROR);
            pageMsg.addProperty("When searching by example, a valid page is required.");
            MessageManager.addMessage(pageMsg);
        } else if(size == null) {
            Message sizeMsg = MessageFactory.createMessage();
            sizeMsg.setKey("${entity.name}BO.findByExample.requiresSize");
            sizeMsg.setSeverity(Severity.ERROR);
            sizeMsg.addProperty("When searching by example, a valid size is required.");
            MessageManager.addMessage(sizeMsg);
	    } else {
	        Pageable pageable = new PageRequest(page, size, sort);
	        result = getDefaultRepository().findAll(Example.of(probe), pageable);	        
	    }
	    return result;
    }
#end

	/**
	 * Provide an opportunity to interact with the object after it is found, but before it is 
	 * returned by {@link ${entity.name}BO#findByPrimaryKey(${idFieldJavaType})} and other 
	 * primary key based retrieval methods.
	 */
	protected void postFindByPrimaryKey() {
	}

#if ( !$entity.isTransient() && !$entity.isNonPersistentParentEntity() )	
	@Override
	protected ${entity.name}Repository getRepository() {
		return repository;
	}
	
	protected static ${entity.name}Repository getDefaultRepository() {
		${entity.name}BO unusedBizObj = new ${entity.name}BO();
		return unusedBizObj.getRepository();
	}
#end

#foreach ($relation in $entity.relations.values())
#if ( !$entity.isTransient() )
	@OneToMany(mappedBy="parent${entity.name}", cascade=CascadeType.ALL, fetch=FetchType.${relation.fetchMode.toUpperCase()}, orphanRemoval=true)
#end
	private Set<${relation.type}BO> ${relation.label}s;
#end
#foreach ($inverseRelation in $entity.inverseRelations.values())
	#if ( !$entity.isTransient() )		
	@ManyToOne(fetch=FetchType.LAZY)
	@JoinColumn(name=#if(!$inverseRelation.idFields.isEmpty())#set($inverseRelationKey = ${inverseRelation.idFields.values().iterator().next()}) "${inverseRelationKey.column}", referencedColumnName="${inverseRelationKey.parentColumn}#else"${inverseRelation.Name}_ID#end", nullable=false)
	#end
	private ${inverseRelation.name}BO parent${inverseRelation.name};
#end
#foreach ($reference in $entity.references.values())

	#if ( !$entity.isTransient() && !$reference.isExternal())
	@ManyToOne(fetch=FetchType.EAGER #if($reference.isRequired()), optional=false#end)
	@JoinColumn(name="${reference.foreignKeyFields.iterator().next().column}")	
    #if ( $reference.isRequired() )
	@NotNull
    #end
  #end	
  #if (!$reference.isExternal())
	private ${reference.type}BO ${reference.name};
  #else
  	@Transient
  	private ${reference.type} ${reference.name};
  #end
  #if ($reference.isExternal() )
  	#if ( !$entity.isTransient() )
  	@Inject
  	@Transient
	private ${reference.type}MaintenanceDelegate ${reference.name}Delegate;
  	
    	@Column(name="${reference.foreignKeyFields.iterator().next().column}")
  	#end
  	#if ( $reference.isRequired() )
	@NotNull
  	#end
  	private ${reference.foreignKeyFields.iterator().next().javaType}	${reference.name}Key;
  
  #end
#end

#foreach ( $idField in $entity.idFields.values() )

	/**
	 * Get the ${idField.label}.
	 *
	 * @return The ${idField.label}
	 */
	protected ${idField.javaType} get${idField.capitalizedName}() {
		return ${idField.name};
	}
	
	/**
	 * Set the ${idField.label}.
	 *
	 * @param The ${idField.label}
	 */
	protected void set${idField.capitalizedName}(${idField.javaType} ${idField.name}) {
		this.${idField.name} = ${idField.name};
	}
#end

#foreach ( $field in $entity.fields.values() )
	/**
  #if ($field.documentation)
	 * Gets: ${field.documentation}.
  #else
	 * Get the ${field.label}.
  #end
	 *
	 * @return The ${field.label}
	 */
	public ${field.javaType} get${field.capitalizedName}() {
		return ${field.name};
	}
	
	/**
  #if ($field.documentation)
	 * Sets: ${field.documentation}.
  #else
	 * Set the ${field.label}.
  #end
	 *
	 * @param The ${field.label}
	 */
	public void set${field.capitalizedName}(${field.javaType} ${field.name}) {
		this.${field.name} = ${field.name};
	}
#end

#foreach ($inverseRelation in $entity.inverseRelations.values())

	/**
	 * Set the parent ${inverseRelation.name} onto this instance.
	 * @param parent The parent instance to set
	 */
	public void set${inverseRelation.name}(${inverseRelation.name}BO parent) {
		parent${inverseRelation.name} = parent;
	}
	
	/**
	 * Returns the parent of the type for this instance.
	 * @return The parent instance or null if no parent of this type exists
	 */
	public ${inverseRelation.name}BO get${inverseRelation.name}() {
		return parent${inverseRelation.name};
	}	
#end

#foreach ($relation in $entity.relations.values()) 

	/**
  #if ($relation.documentation)
	 * Sets: ${relation.documentation}.
  #else
	 * Set the ${relation.label} relation.
  #end
	 * 
	 * @param Set - The ${relation.label}s
	 */
	public void set${relation.type}s(Set<${relation.type}BO> ${relation.label}s) {
		this.${relation.label}s = ${relation.label}s;
	} 

	/**
  #if ($relation.documentation)
	 * Gets: ${relation.documentation}.
  #else
	 * Get the ${relation.label} relation.
  #end
	 * 
	 * @return Set - The ${relation.label}s
	 */
	public Set<${relation.type}BO> get${relation.type}s() {
		if( ${relation.label}s == null ) {
			${relation.label}s = new HashSet<${relation.type}BO>();
		}
		
		return ${relation.label}s;
	}
	 
	/**
  #if ($relation.documentation)
	 * Adds: ${relation.documentation}.
  #else
	 * Add a ${relation.label}.
  #end
	 *
	 * @param The ${relation.label} to add
	 */
	public void add${relation.type}(${relation.type}BO ${relation.label}) {
		Set<${relation.type}BO> childSet = get${relation.type}s();
		if (childSet == null) {
			childSet = new HashSet<${relation.type}BO>();
			set${relation.type}s(childSet);
		}
		
		${relation.label}.set${entity.name}( (${entity.name}BO) this );
		childSet.add( ${relation.label} );
	}
	 
	/**
  #if ($relation.documentation)
	 * Removes: ${relation.documentation}.
  #else
	 * Remove a ${relation.label}.
  #end
	 *
	 * @param The ${relation.label} to remove
	 */
	public ${relation.type}BO remove${relation.type}(${relation.type}BO ${relation.label}) {
		if( get${relation.type}s().remove( ${relation.label} ) ) {
			${relation.label}.set${entity.name}(null);
			
		} else {
			getLogger().error("Could not remove ${relation.label} instance with key " + ${relation.label}.getKey());
			
		}
	    
		return ${relation.label};
	}
#end
#if (!$entity.relations.isEmpty() && !$entity.isTransient())
	/**
	 * Creates a {@link Specification} that eagerly fetches all 1-M relations that are 
	 * present in {@link ${entity.name}BO}. 
	 */
	protected static Specification<${entity.name}BO> eagerFetchRelations() {
		return new Specification<${entity.name}BO>() {

			@Override
			public Predicate toPredicate(Root<${entity.name}BO> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
				for (PluralAttribute<? super ${entity.name}BO, ?, ?> fetch : root.getModel().getPluralAttributes()) {
					root.fetch(fetch, JoinType.LEFT);
				}
				query.distinct(true);
				return null;
			}

		};
	}
	
	/**
	 * Creates a {@link Specification} that filters {@link ${entity.name}BO}s that have an ${idField.name} that 
	 * matches the given key. 
	 */
	protected static Specification<${entity.name}BO> keyEquals(final ${idFieldJavaType} key) {
		return new Specification<${entity.name}BO>() {

			@Override
			public Predicate toPredicate(Root<${entity.name}BO> root, CriteriaQuery<?> query, CriteriaBuilder cb) {
				return cb.equal(root.get("${idField.name}"), key);
			}

		};
	}
#end
#foreach ($reference in $entity.references.values())
  #if ( !$reference.isExternal() )

	/**
	 * Get the ${reference.label} reference.
	 *
	 * @return ${reference.type}BO - The ${reference.label}
	 */
	public ${reference.type}BO get${reference.capitalizedName}() {
		return ${reference.name};
	}
	 
	/**
	 * Set the ${reference.label} reference.
	 *
	 * @param The ${reference.label}
	 */
	public void set${reference.capitalizedName}(${reference.type}BO ${reference.name}) {
		this.${reference.name} = ${reference.name};
	}

  #else
	
	/**
	 * Get the ${reference.label} reference.
	 *
	 * @return ${reference.type} - The ${reference.label}
	 */
	public ${reference.type} get${reference.capitalizedName}() {
		if ((${reference.name} == null) && (${reference.name}Key != null)) {
			${reference.name} = ${reference.name}Delegate.findByPrimaryKey(${reference.name}Key);
		    set${reference.getCapitalizedName()}(${reference.name});
		}
		
		return ${reference.name};
	}
	 
	/**
	 * Set the ${reference.label} reference.
	 *
	 * @param The ${reference.label}
	 */
	public void set${reference.capitalizedName}(${reference.type} ${reference.name}) {
		this.${reference.name} = ${reference.name};
		this.${reference.name}Key = ${reference.name} != null ? ${reference.name}.get${reference.foreignKeyFields.iterator().next().getCapitalizedName()}() : null;
	}
  #end
				
#end
	
	/**
	 * Executes field-level validations on all child relations.
	 */
	@Override 
	protected void validateRelations() {		
#if( !$entity.relations.isEmpty() )
		//call field validation on children:
  #foreach ($relation in $entity.relations.values())
		Set<${relation.type}BO> ${relation.label}Set = get${relation.type}s();
		if (${relation.label}Set != null && !${relation.label}Set.isEmpty()) {
			for (${relation.type}BO child : ${relation.label}Set) {
				child.validateFields();
			}
		}

  #end		
#end
	}	
		
	/**
	 * Executes all complex validation on child relations.
	 */
	@Override 
	protected void complexValidationOnRelations() {
#if( !$entity.relations.isEmpty() )
		//call complex validation on children:
  #foreach ($relation in $entity.relations.values())
		Set<${relation.type}BO> ${relation.label}Set = get${relation.type}s();
		if (${relation.label}Set != null && !${relation.label}Set.isEmpty()) {
			for (${relation.type}BO child : ${relation.label}Set) {
				child.complexValidation();
			}
		}

  #end		
#end
	}

	/**
      * {@inheritDoc}
      */
      public String toString(){
         return ReflectionToStringBuilder.toString(this);
      }
      
      /**
      * Executes field-level validations on all references.
      */
      @Override 
      protected void validateReferences() {
		#foreach ($reference in $entity.references.values())
		  #if ( !$reference.isExternal() )
		    #if( !$entity.references.isEmpty() ) 
				${reference.type}BO ${reference.name}Ref = get${reference.capitalizedName}();
				if ((${reference.name}Ref != null && ${reference.name}Ref.getKey() != null)) {
					${reference.type}BO found${reference.type}Ref = ${reference.type}BO.findByPrimaryKey(${reference.name}Ref.getKey());
				    this.checkIfReferenceExists(found${reference.type}Ref);
				}
			#end
		  #else
		    #if( !$entity.references.isEmpty() ) 
				${reference.type} ${reference.name}Ref = 	get${reference.capitalizedName}();				
				if ((${reference.name}Ref != null && ${reference.name}Key != null)) {
					${reference.type} found${reference.type}Ref = ${reference.name}Delegate.findByPrimaryKey(${reference.name}Key);
				    this.checkIfReferenceExists(found${reference.type}Ref);
				}
			#end
		  #end				
		#end
      }
}