package ${prefix}.transfer;

import org.tigris.atlas.transfer.PrimaryKey;
#foreach ($pkImport in $pkImports )
import ${pkImport};
#end
import java.io.Serializable;

/**
 * Primary Key for the ${entityName} application entity
 *
 * Generated Code - DO NOT MODIFY
 */
 
public class ${entityName}PK implements PrimaryKey {

	//private static ${entityName}PKSchemaAssembler assembler = new ${entityName}PKSchemaAssembler();

#foreach( $idField in $idFields ) 
	private ${idField.javaType}		${idField.name};
#end
	
	/**
	 * @deprecated Use specialized constructors instead.
	 * Will be removed as of release 0.9.3
	 */
	public ${entityName}PK() {
	}
	
	/**
	 * Answer the type of entity for this PK
	 *
	 * @return String The logical entity name
	 */
	public String getEntityName() {
		return ${entityName}.ENTITY;
	}
	
	public ${entityName}PK(${entity.keySignature}) {
#foreach( $idField in $idFields ) 
		this.${idField.name} = ${idField.name};
#end
	}

	public ${entityName}PK(${entityName} entity) {
#foreach( $idField in $idFields ) 
		this.${idField.name} = entity.get${idField.capitalizedName}();
#end
	}
#foreach ( $idField in $idFields )

	/**
	 * Get the ${idField.label}
	 *
	 * @return The ${idField.label}
	 */
	public ${idField.javaType} get${idField.capitalizedName}() {
		return ${idField.name};
	}
	
	/**
	 * Set the ${idField.label}
	 *
	 * @param ${idField.type} The ${idField.label}
	 */
	public void set${idField.capitalizedName}(${idField.javaType} ${idField.name}) {
		this.${idField.name} = ${idField.name};
	}
#end

	/**
	 * Get the string representation of this pk
	 *
	 * @return String The PK string
	 */
	public String toString() {
		String s = new String();
#foreach( $idField in $idFields ) 
		s = s + ${idField.name}.toString();
#end
		return s;
	}
	
	/**
	 * Get the value.  Used by the framework for persistence ops
	 *
	 */
	public Serializable getValue() {
#if( $idFields.size() > 1 || $idReferences.size() > 0 )
		return this;
#else
#foreach( $idField in $idFields )
		return ${idField.name};
#end
#end
	}
	
	/**
	 * Override <tt>hashCode()</tt> so that this class can be seamlessly 
	 * used in hash-based collections.
	 * @param o The <tt>Object</tt> to which this instance should be compared
	 * @return <tt>true</tt> if equals, <tt>false</tt> otherwise
	 */
	public boolean equals(Object o) {
		boolean areEqual = false;
			
		try {		
			${entityName}PK entity = (${entityName}PK)o;		
#foreach ( $idField in $idFields )		
			${idField.javaType} entity${idField.capitalizedName} = (entity != null) ? entity.get${idField.capitalizedName}() : null;			
			if (${idField.name} == null && entity${idField.capitalizedName} == null) {
				return super.equals(o);
			}
			if (${idField.name} == entity${idField.capitalizedName} 
			|| (${idField.name} != null && ${idField.name}.equals(entity${idField.capitalizedName}))) {
				areEqual = true;
			}
#end
				
		} catch (ClassCastException cce) {
			areEqual = false;
		}
						
		return areEqual;
	}	
		
	/**
	 * Generate a unique hash.
	 * NOTE: If you put this object into a hash-based collection, you must remove it if 
	 * you decide to update the fields from which the hashCode is derived.  This is 
	 * because the hashCode is derived from the superclass of this instance if no
	 * key fields have been defined.
	 */
	public int hashCode() {
		int hashCode = 0;
#foreach ( $idField in $idFields )
		hashCode = (${idField.name} != null) ? ${idField.name}.hashCode() : super.hashCode();
#end		
		return hashCode;
	}
		
}