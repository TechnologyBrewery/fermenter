package ${prefix}.transfer;

//import ${prefix}.transfer.schema.${entityName}SchemaAssembler;
#foreach ($import in $imports )
import ${import};
#end
#foreach( $reference in $references ) 
#if( $reference.isExternal() )
import ${reference.importPrefix}.transfer.${reference.type};
import ${reference.importPrefix}.transfer.${reference.type}PK;
#end
#end
#foreach ($composite in $composites)
import ${prefix}.transfer.${composite.type}Composite;
#end
import org.tigris.atlas.transfer.*;

import java.util.Collection;
import java.util.ArrayList;
import java.util.UUID;
#if( $relations.size() > 0 )  
import java.util.HashSet;
import java.util.Set;
import java.util.Iterator;
#end
import org.apache.commons.lang.StringUtils;

/**
 * Transfer object for the ${entityName} application entity.
#if ($entity.documentation)
 * ${entity.documentation}
#end
 *
 * Generated Code - DO NOT MODIFY
 */
public class ${entityName} extends ${extends}TO {

	private static final long serialVersionUID = ${uid}L;

	/**
	 * Transient ID that is not persistent but guaranteed to be non-null during an object's lifecycle
	 * and thereby usable in hashCode() and equals() methods as a fallback for scenarios where an entity
	 * may not have a non-null {@link PrimaryKey} value.
	 */
	protected final UUID internalTransientID = UUID.randomUUID();
	
	public static final String ENTITY = "${prefix}.${entityName}";	

#foreach ( $idField in $idFields )
	private ${idField.javaType} ${idField.name};
#end
#if ($useOptimisticLocking)	 
	private Integer oplock;
#end
#foreach ( $field in $fields )
	private ${field.javaType} ${field.name};
#end
#foreach ($relation in $relations)
	private Set<${relation.type}> ${relation.label}s;
#end
#foreach ($inverseRelation in $inverseRelations)
	private ${inverseRelation.name} parent${inverseRelation.name};
#end
#foreach ($reference in $references)
	private ${reference.type} ${reference.name};
#end
#foreach ($composite in $composites)
	private ${composite.type}Composite ${composite.name}Composite;
#end


	/**
	 * Answer the logical entity name
	 *
	 * @return String - The logical entity name
	 */
	public String getEntityName() {
		return ENTITY;
	}

#foreach ( $idField in $idFields )

	/**
	 * Get the ${idField.label}
	 *
	 * @return The ${idField.label}
	 */
	public ${idField.javaType} get${idField.capitalizedName}() {
		return ${idField.name};
	}
	
	/**
	 * Set the ${idField.label}
	 *
	 * @param ${idField.type} The ${idField.label}
	 */
	public void set${idField.capitalizedName}(${idField.javaType} ${idField.name}) {
#if ($field.getJavaType().equals("String"))
		StringUtils.trimToNull(${idField.name});
#end	
		this.${idField.name} = ${idField.name};
	}
	
#end
#if ($useOptimisticLocking)	 

	/**
	 * Get the optimistic locking value
	 * @return The optimistic locking value 
	 */
	public Integer getOplock() {
		return oplock;
	}
	
	/**
	 * Set the optimistic locking value
	 * @param The optimistic locking value
	 */
	private void setOplock(Integer oplock) {
		this.oplock = oplock;
	}

#end
#foreach ( $field in $fields )

	/**
#if ($field.documentation)
	 * Gets: ${field.documentation}
#else
	 * Get the ${field.label}
#end
	 *
	 * @return The ${field.label}
	 */
	public ${field.javaType} get${field.capitalizedName}() {
		return ${field.name};
	}
	
	/**
#if ($field.documentation)
	 * Sets: ${field.documentation}
#else
	 * Set the ${field.label}
#end
	 *
	 * @param ${field.type} The ${field.label}
	 */
	public void set${field.capitalizedName}(${field.javaType} ${field.name}) {
#if ($field.getJavaType().equals("String"))
		${field.name} = StringUtils.trimToNull(${field.name});
#end		
		this.${field.name} = ${field.name};
	}
	
#end
#foreach ($inverseRelation in $inverseRelations)

	/**
	 * Set the parent ${inverseRelation.name} onto this instance
	 * @param parent The parent instance to set
	 */
	public void set${inverseRelation.name}(${inverseRelation.name} parent) {
		parent${inverseRelation.name} = parent;
	}
	
	/**
	 * Returns the parent of the type for this instance
	 * @return The parent instance or null if no parent of this type exists
	 */
	public ${inverseRelation.name} get${inverseRelation.name}() {
		return parent${inverseRelation.name};
	}
#end
#foreach ($composite in $composites)
	/**
	 * Get the ${composite.label} composite for this instance.
	 *
	 * @return The ${composite.label} composite
	 */
	public ${composite.type}Composite get${composite.capitalizedName}Composite() {
		if (${composite.name}Composite == null) {
			${composite.name}Composite = new ${composite.type}Composite();
		}

		return ${composite.name}Composite;
	}
#end
#foreach ($relation in $relations)

	/**
#if ($relation.documentation)
	 * Sets: ${relation.documentation}
#else
	 * Set the ${relation.label} relation.
#end
	 * 
	 * @param Set - The ${relation.label}s
	 */
	public void set${relation.type}s(Set<${relation.type}> ${relation.label}s) {
		this.${relation.label}s = ${relation.label}s;
	} 

	/**
#if ($relation.documentation)
	 * Gets: ${relation.documentation}
#else
	 * Get the ${relation.label} relation.
#end
	 * 
	 * @return Set - The ${relation.label}s
	 */
	public Set<${relation.type}> get${relation.type}s() {
		if( ${relation.label}s == null ) {
			${relation.label}s = new HashSet();
		}
		
		return ${relation.label}s;
	}
	 
	/**
#if ($relation.documentation)
	 * Adds: ${relation.documentation}
#else
	 * Add a ${relation.label}.
#end
	 *
	 * @param The ${relation.label} to add
	 */
	public void add${relation.type}(${relation.type} ${relation.label}) {
		if( get${relation.type}s().contains( ${relation.label} ) ) {
			get${relation.type}s().remove( ${relation.label} );
		}
		
		${relation.label}.set${entityName}( this );
		get${relation.type}s().add( ${relation.label} );
	}
	 
	/**
#if ($relation.documentation)
	 * Removes: ${relation.documentation}
#else
	 * Remove a ${relation.label}.
#end
	 *
	 * @param The ${relation.label} to remove
	 */
	public ${relation.type} remove${relation.type}(${relation.type} ${relation.label}) {
		if( get${relation.type}s().remove( ${relation.label} ) ) {
			${relation.label}.set${entityName}(null);
		}
	    
		return ${relation.label};
	}
#end
#foreach ($reference in $references) 
	
	/**
#if ($reference.documentation)
	 * Gets: ${reference.documentation}
#else
	 * Get the ${reference.label} reference
#end
	 *
	 * @return ${reference.type} - The ${reference.label}
	 */
	public ${reference.type} get${reference.capitalizedName}() {
		return ${reference.name};
	}
	 
	/**
#if ($reference.documentation)
	 * Sets: ${reference.documentation}
#else
	 * Set the ${reference.label} reference
#end
	 *
	 * @param The ${reference.label}
	 */
	public void set${reference.capitalizedName}(${reference.type} ${reference.name}) {
		this.${reference.name} = ${reference.name};
	}
#end
#if ( $idFields.size() > 0 )

	/**
	 * Get the primary key for the ${entityName}
	 *
	 */
	public PrimaryKey getKey() {
		return get${entityName}PK();
	}
	
	/**
	 * Get the primary key for the ${entityName}
	 *
	 */
	public ${entityName}PK get${entityName}PK() {
		return new ${entityName}PK( ${entity.keySignatureParams} ); 
	}
	
	/**
	 * Set the key fields from the primary key
	 *
	 */
	public void setKey(PrimaryKey pk) {
		set${entityName}PK( (${entityName}PK) pk ); 
	}
	 
	/**
	 * Set the key fields from the primary key
	 *
	 */
	public void set${entityName}PK(${entityName}PK pk) {
#foreach ( $idField in $idFields )
		this.${idField.name} = pk.get${idField.capitalizedName}();
#end		
	}
#else

	/**
	 * Get the key field for the ${entityName}
	 *
	 */
	public PrimaryKey getKey() {
		return null;
	}
	
	/**
	 * Set the key field
	 *
	 */
	public void setKey(PrimaryKey key) {
	}
#end	 

	public boolean equals(Object o) {
		boolean areEqual = false;
		
		try {
			$entityName to = ($entityName) o;
			// Can't be null!
			PrimaryKey thisPk = getKey();
			PrimaryKey thatPk = (to == null) ? null : to.getKey();
			if (thatPk != null && thisPk.getValue() == null && thatPk.getValue() == null) {
				return this.internalTransientID == to.internalTransientID;
			}
			if (thisPk == thatPk || (thisPk.equals(thatPk))) {
				areEqual = true;
			}
		} catch (ClassCastException ex) {
			areEqual = false;
		}
		
		return areEqual;
	}
	
	public int hashCode() {
		return (getKey().getValue() == null) ? internalTransientID.hashCode() : getKey().getValue().hashCode();
	}

}
