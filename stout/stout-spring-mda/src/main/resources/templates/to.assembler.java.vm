package ${prefix}.bizobj;

import ${prefix}.transfer.${entityName};

#foreach ($inverseRelation in $inverseRelations)
import ${prefix}.transfer.${inverseRelation.name};
#end

#foreach ($relation in $relations)
import ${prefix}.transfer.${relation.type};
#end
#foreach ($composite in $composites)
import ${prefix}.transfer.${composite.type}Composite;
#end
#foreach ($reference in $references)
#if( $reference.isExternal() )
import ${reference.importPrefix}.transfer.${reference.type};
#else
import ${prefix}.transfer.${reference.type};
import ${prefix}.transfer.${reference.type}PK;
#end
#end

#if( $relations.size() > 0 )  
import java.util.Set;
import java.util.Map;
import java.util.HashMap;
#end
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;

import org.bitbucket.fermenter.stout.bizobj.TransferObjectAssembler;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * Transfer object assembler for the ${entityName} application entity.  This class is used create new instances of 
 * {@link ${entityName}} from an instance of a/an {@link ${entityName}BO} or the inverse.  It is also used to merge
 * an instance of a/an ${entityName}BO with the values of a ${entityName} instance.
 *
 * Generated Code - DO NOT MODIFY
 */
public final class ${entityName}Assembler extends TransferObjectAssembler {

	private static final Logger LOGGER = LoggerFactory.getLogger(${entityName}Assembler.class);
	
	private ${entityName}Assembler() {
		//prevent instantiation
	}
	
	/**
	 * Given a list of {@link ${entityName}BO} instances, create a list of {@link ${entityName}}
	 * instances.  This will iterate over the list of {@link ${entityName}BO} instances,
	 * create a(n) {@link ${entityName}} instance from the {@link ${entityName}BO} instance, and
	 * add the new {@link ${entityName}} instance to the result list.
	 */	 
	public static List<${entityName}> get${entityName}List(Collection<${entityName}BO> bos) {
		if (bos == null) {
			return null;
		}
		
		List<${entityName}> tos = new ArrayList<${entityName}>(bos.size());
		for (${entityName}BO bo : bos) {
			tos.add(create${entityName}(bo));
		}
		
		return tos;
	}
	
	/**
	 * Given a list of {@link ${entityName}} instances, create a list of {@link ${entityName}BO}
	 * instances.  This will iterate over the list of {@link ${entityName}} instances,
	 * create a(n) {@link ${entityName}BO} instance from the {@link ${entityName}} instance, and
	 * add the new {@link ${entityName}BO} instance to the result list.
	 */	 
	public static List<${entityName}BO> get${entityName}BOList(Collection<${entityName}> tos) {
		if (tos == null) {
			return null;
		}
		
		List<${entityName}BO> bos = new ArrayList<${entityName}BO>(tos.size());
		for (${entityName} to : tos) {
			bos.add(merge${entityName}BO(to, null));
		}
		
		return bos;
	}	
	
	/**
	 * Creates a new transfer object based on the passed business object, including children.
	 * @param bo The {@link ${entity.name}BO} that should be made transportable
	 * @return The transportable version of the passed business object
	 */
	public static ${entityName} create${entityName}(${entityName}BO bo) {
		return create${entityName}(bo, true);
	}	
	
	/**
	 * Creates a new transfer object based on the passed business object.
	 * @param bo The {@link ${entity.name}BO} that should be made transportable
	 * @param createChildren flag to suppress child creation
	 * @return The transportable version of the passed business object
	 */
	public static ${entityName} create${entityName}(${entityName}BO bo, boolean createChildren) {
		${entityName} to = new ${entityName}();		
		
		if (bo != null) {
			//pull over all fields:
#foreach ( $idField in $idFields )
			to.set${idField.capitalizedName}(bo.get${idField.capitalizedName}());
#end
#foreach ( $field in $fields )
			to.set${field.capitalizedName}(bo.get${field.capitalizedName}());
#end
#if ($useOptimisticLocking)	 
			setOplockOnTransferObject(to, bo.getOplock());
#end

			//pull over composites:
#foreach ($composite in $composites)

			${composite.type}Composite to${composite.capitalizedName}Composite = to.get${composite.capitalizedName}Composite();
			${composite.type}BOComposite bo${composite.capitalizedName}Composite = bo.get${composite.capitalizedName}Composite();
	#foreach ($field in ${composite.fields})
			to${composite.capitalizedName}Composite.set${field.capitalizedName}(bo${composite.capitalizedName}Composite.get${field.capitalizedName}());
	#end
#end

			//pull over parent:
#foreach ($inverseRelation in $inverseRelations)
	   		${inverseRelation.name} parent${inverseRelation.name} = ${inverseRelation.name}Assembler.create${inverseRelation.name}(bo.get${inverseRelation.name}(), false);
			to.set${inverseRelation.name}(parent${inverseRelation.name});
#end
			
#if ($relations.size() > 0)
			//pull over relations:
			if (createChildren)	{
	#foreach ($relation in $relations)
				${relation.type}BO ${relation.label}Bo;
				${relation.type} ${relation.label}To;
				Set	${relation.label}Set = bo.get${relation.type}s();
				if ((${relation.label}Set != null) && (${relation.label}Set.size() > 0)) {
					Iterator ${relation.label}SetIterator = ${relation.label}Set.iterator();
					while (${relation.label}SetIterator.hasNext()) {
						${relation.label}Bo = (${relation.type}BO)${relation.label}SetIterator.next();
						${relation.label}To = ${relation.label}Bo.get${relation.type}Values();
						to.add${relation.type}(${relation.label}To);
					}
				}
	#end
			}	
#else
			//no relations to assemble
#end

			//pull over references:
#foreach ($reference in $references)
#if( $reference.isExternal() )
			to.set${reference.capitalizedName}( bo.get${reference.capitalizedName}() );
#else
			${reference.type}BO ${reference.name}Ref = bo.get${reference.capitalizedName}();
			if (${reference.name}Ref != null) {
				to.set${reference.capitalizedName}(${reference.name}Ref.get${reference.type}Values());
			
			}
#end			
#end
			
		}
		
		return to;
		
	}
	
	/**
	 * Merges the values of the passed transfer object into the passed business object.  If the passed business
	 * object is null, it creates a new one.  Include merging of all children.
	 * @param to The {@link ${entity.name}} that has more up-to-date values that should be 
	 * propagated onto the passed business object
	 * @param bo The {@link ${entity.name}BO} that should be updated with the values of the 
	 * passed transfer object (or null if no version of the business object currently exists
	 * @return The updated business object
	 */
	public static ${entityName}BO merge${entityName}BO(${entityName} to, ${entityName}BO bo) {
		return merge${entityName}BO(to, bo, true);
	}
	
	/**
	 * Merges the values of the passed transfer object into the passed business obejct.  If the passed business
	 * object is null, it creates a new one.
	 * @param to The {@link ${entity.name}} that has more up-to-date values that should be 
	 * propagated onto the passed business object
	 * @param bo The {@link ${entity.name}BO} that should be updated with the values of the 
	 * passed transfer object (or null if no version of the business object currently exists
	 * @param mergeChildren whether or not to suppress the merging of children
	 * @return The updated business object
	 */
	public static ${entityName}BO merge${entityName}BO(${entityName} to, ${entityName}BO bo, boolean mergeChildren) {
		if (bo == null) {
			bo = BusinessObjectFactory.create${entityName}BO();
		}		
		
		if ((to != null) && (bo != null)) {			
#foreach ( $idField in $idFields )
			bo.set${idField.capitalizedName}(to.get${idField.capitalizedName}());
#end
#foreach ( $field in $fields )
			bo.set${field.capitalizedName}(to.get${field.capitalizedName}());
#end
#if ($useOptimisticLocking)	 
			bo.setOplock(to.getOplock());
#end

			//pull over composites:
#foreach ($composite in $composites)

			${composite.type}Composite to${composite.capitalizedName}Composite = to.get${composite.capitalizedName}Composite();
			${composite.type}BOComposite bo${composite.capitalizedName}Composite = bo.get${composite.capitalizedName}Composite();
#foreach ($field in ${composite.fields})
			bo${composite.capitalizedName}Composite.set${field.capitalizedName}(to${composite.capitalizedName}Composite.get${field.capitalizedName}());
#end
#end

			//pull over parent:
#foreach ($inverseRelation in $inverseRelations)
	   		${inverseRelation.name}BO parent${inverseRelation.name} = ${inverseRelation.name}Assembler.merge${inverseRelation.name}BO(to.get${inverseRelation.name}(), null, false);
			bo.set${inverseRelation.name}(parent${inverseRelation.name});
#end

#if ($relations.size() > 0)
			//pull over relations:
			if (mergeChildren) {
	#foreach ($relation in $relations)
				assemble${relation.type}(to, bo);			
	#end
			}
#else
			//no children to merge
#end

			//pull over references:
#foreach ($reference in $references)
	#if( $reference.isExternal() )
			bo.set${reference.capitalizedName}( to.get${reference.capitalizedName}() );
	#else
			${reference.type} ${reference.name}ToRef = to.get${reference.capitalizedName}();
			if (${reference.name}ToRef != null) {
				${reference.type}PK ${reference.name}Pk = (${reference.type}PK)${reference.name}ToRef.getKey();
				${reference.type}BO ${reference.name}Ref = ${reference.type}BO.findByPrimaryKey(${reference.name}Pk);
				if (${reference.name}Ref != null) {
					bo.set${reference.capitalizedName}(${reference.name}Ref);
					
				} else {
					//just translate it over - we'll check to ensure it is valid before saving, but this
					//gives folks a chance to do something with the inbound data before we cull it:
					${reference.type}BO potential${reference.capitalizedName}Ref = ${reference.type}Assembler.merge${reference.type}BO(${reference.name}ToRef, null);
					bo.set${reference.capitalizedName}(potential${reference.capitalizedName}Ref);
					
				}
			}	
			
	#end
#end	
						
		}
		
		return bo;
	
	}

#foreach ($relation in $relations)
	/**
	 * Uses set comparison to transfer a collection of children onto the business object 
	 * instance.
	 * @param to The {@link ${entity.name}} that has more up-to-date values that should be 
	 * propogated onto the passed business object
	 * @param bo The {@link ${entity.name}BO} that should be updated with the values of the 
	 * passed transfer object
	 */
	protected static void assemble${relation.type}(${entityName} to, ${entityName}BO bo) {
		//get the set of to relations (transient view):		
		Set	${relation.label}ToSet = to.get${relation.type}s();
		
		if ((${relation.label}ToSet != null) && (${relation.label}ToSet.size() > 0)) {
			${relation.type} ${relation.label}To;
			//get the set of bo relations (persistence view).  Turn this set into a
			//key-value pair so we can compare PrimaryKey instances:
			${relation.type}BO ${relation.label}Bo;			
			Set	${relation.label}BoSet = bo.get${relation.type}s();
			int size = (${relation.label}BoSet != null) ? ${relation.label}BoSet.size() : 0;
			Map ${relation.label}KeyToBoMap = new HashMap((int)(size * 1.25));
			if (size > 0) {
				Iterator ${relation.label}BoSetIterator = ${relation.label}BoSet.iterator();
				while (${relation.label}BoSetIterator.hasNext()) {
					${relation.label}Bo = (${relation.type}BO)${relation.label}BoSetIterator.next();
					${relation.label}KeyToBoMap.put(${relation.label}Bo.getKey(), ${relation.label}Bo);
					
				}
			}
			
			
			//iterate over the children and perform the correct CRUD action:
			Iterator ${relation.label}ToSetIterator = ${relation.label}ToSet.iterator();
			while (${relation.label}ToSetIterator.hasNext()) {
				${relation.label}To = (${relation.type})${relation.label}ToSetIterator.next();
				${relation.label}Bo = (${relation.type}BO)${relation.label}KeyToBoMap.get(${relation.label}To.getKey());
				
				if (${relation.label}Bo == null) {
					//this instance isn't known to the BO, so it is a create:
					${relation.label}Bo = new ${relation.type}BO();
					bo.add${relation.type}(${relation.label}Bo);					
					
				} else {
					//remove the reference from the temp. BO map.  Anything left in this map will
					//be removed from the BO:
					${relation.label}KeyToBoMap.remove(${relation.label}Bo.getKey());
				}
				
				//update this instance with the TO:
				${relation.label}Bo.set${relation.type}Values(${relation.label}To);
										
			}
			
			//loop over any remaining BOs and delete them:
			if (${relation.label}KeyToBoMap.size() > 0) {
				Iterator ${relation.label}KeyToBoMapIterator = ${relation.label}KeyToBoMap.values().iterator();
				while (${relation.label}KeyToBoMapIterator.hasNext()) {
					${relation.label}BoSet.remove(${relation.label}KeyToBoMapIterator.next());
				
				}
			}
			
		} else {
			bo.get${relation.type}s().clear();
		
		}
		
	}
	
#end
	
}
