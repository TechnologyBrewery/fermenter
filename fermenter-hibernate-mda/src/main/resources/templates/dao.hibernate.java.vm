package ${prefix}.persist.hibernate;

#if( $queries.size() > 0 )
import java.util.List;
#foreach($query in $queries)
#foreach($criteria in $query.criteria)
import ${criteria.import};
#end
#end
#end

#if( $relations.size() > 0 )
import java.util.Iterator;
import java.util.Set;
import java.util.HashSet;

import org.tigris.atlas.persist.Dao;
#end
import org.tigris.atlas.persist.hibernate.DaoImpl;
import org.tigris.atlas.validate.Validated;

import ${prefix}.bizobj.${entityName}BO;
import ${prefix}.transfer.${entityName};
import ${prefix}.transfer.${entityName}PK;
import ${prefix}.persist.${entityName}Dao;

import org.hibernate.Hibernate;
import org.hibernate.type.Type;

#foreach ($import in $imports )
import ${import};
#end

/**
 * Data access object for the ${entityName} application entity
 *
 * Generated Code - DO NOT MODIFY
 */
public class ${entityName}DaoImpl extends DaoImpl implements ${entityName}Dao {
	
	private static final String NAMESPACE = "${prefix}";
	
	/**
	 * Answer the logical entity persisted by this DAO
	 *
	 * @return String The entity name
	 */
	public String getEntityName() {
		return ${entityName}.ENTITY;
	}
	
	/**
 	 * Answer the namespace for this DAO.  This is used to get the SessionFactory from the context.
 	 *
 	 * @return String The DAO namespace.
 	 */
 	protected final String getNamespace() {
 		return NAMESPACE;
 	}
	
#if( $parent == "null" )
	
	/**
	 * Save the ${entityName}
	 *
	 * @param entity ${entityName} to save
	 * @return ${entityName} The saved ${entityName}
	 */
	public ${entityName}BO save${entityName}(Validated validValues) {
		${entityName}BO bo = (${entityName}BO) super.save( validValues );
			
#foreach ($relation in $relations) 
		//Works around a programmatic key issue with hibernate where hashcode changes once a 
		//programmatic key is assigned.  This prevents removal of BOs when working with a hibernate
		//session that was responsible creating an object you now wish to remove.  This work around
		//solves that by refreshing the relation's set to have any updated hashcodes:
		Set ${relation.label}CurrentSet = bo.get${relation.type}s();
		if (${relation.label}CurrentSet != null) {
			Iterator ${relation.label}Iterator = ${relation.label}CurrentSet.iterator();  
			Set postSave${relation.Type}Set = new HashSet();
			while (${relation.label}Iterator.hasNext()) {
				postSave${relation.Type}Set.add(${relation.label}Iterator.next());
			}
			
			${relation.label}CurrentSet.clear();
			
			${relation.label}CurrentSet.addAll(postSave${relation.Type}Set);
			
		}
		
#end		
		
		return bo;
	}
	
	/**
	 * Delete the ${entityName}
	 *
	 * @param entity ${entityName} to delete
	 * @return ${entityName} The deleted ${entityName}
	 */
	public ${entityName}BO delete(${entityName}PK pk) {
		return (${entityName}BO) super.delete( pk );
	}
	
	/**
	 * Find the ${entityName} by primary key fields
	 *
	 * @param pk The primary key for the ${entityName}
	 * @return ${entityName} The retrieved ${entityName}
	 */
	public ${entityName}BO findByPrimaryKey(${entityName}PK pk) {
		return (${entityName}BO) super.findByPrimaryKey( pk );
	}
#foreach( $query in $queries )	

	/**
	 * Execute the ${query.name} query
	 *
#foreach( $criterion in $query.criteria )
	 * @param ${criterion.name} The ${criterion.name}
#end
	 * @return List of ${entityName}s
	 */	 
#set( $numCriteria = $query.criteria.size() ) 
#set( $currentNum  = 0 )
	public List ${query.lowercaseName}(#foreach( $criterion in $query.criteria )${criterion.javaType} ${criterion.name} #set($currentNum = $currentNum+1)#if($currentNum<$numCriteria), #end#end) {
#set( $cn = 0 )
		String[] paramNames = new String[] { #foreach( $criterion in $query.criteria )"${criterion.name}" #set($cn = $cn+1)#if($cn<$numCriteria), #end#end}; 
#set( $cn = 0 )
		Object[] paramValues = new Object[] { #foreach( $criterion in $query.criteria )${criterion.name} #set($cn = $cn+1)#if($cn<$numCriteria), #end#end }; 
#set( $cn = 0 )
		Type[] paramTypes = new Type[] { #foreach( $criterion in $query.criteria ) #if ($criterion.isSimpleType()) Hibernate.${criterion.getUppercasedType()} #set($cn = $cn+1)#if($cn<$numCriteria), #end #else Hibernate.custom(${criterion.type}UserType.class) #set($cn = $cn+1)#if($cn<$numCriteria), #end #end #end};
		
		return query( ${entityName}Dao.${query.name}, paramNames, paramValues, paramTypes );
	}
#end
#end

}