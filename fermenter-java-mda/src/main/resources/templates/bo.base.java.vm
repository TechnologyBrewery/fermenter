package ${prefix}.bizobj;

import ${prefix}.persist.*;
import ${prefix}.transfer.*;

import org.tigris.atlas.transfer.PrimaryKey;
import org.tigris.atlas.transfer.TransferObject;
import org.tigris.atlas.bizobj.*;
#if( $references.size() > 0 )
import org.tigris.atlas.persist.*;
#end
import org.tigris.atlas.validate.Validated;
import org.tigris.atlas.validate.Validations;
import org.tigris.atlas.messages.Messages;
import org.tigris.atlas.messages.MessagesSet;

#if( $relations.size() > 0 )
import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;
#end
#if( $queries.size() > 0 )
import java.util.List;
#foreach($query in $queries)
#foreach($criteria in $query.criteria)
import ${criteria.import};
#end
#end
#end

#foreach( $reference in $references ) 
#if( $reference.isExternal() )
import ${reference.importPrefix}.transfer.${reference.type};
import ${reference.importPrefix}.transfer.${reference.type}PK;
#end
#end

#foreach ($import in $imports )
import ${import};
#end

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.commons.lang.StringUtils;

import java.lang.reflect.InvocationTargetException;
import java.lang.reflect.Method;
#foreach ($validator in $entity.validators)
import ${validator.import};
#end

/**
 * Business object for the ${entityName} application entity.
#if ($entity.documentation)
 * ${entity.documentation}
#end
 *
 * Generated Code - DO NOT MODIFY
 */
 
public abstract class ${entityName}BaseBO extends ${extends}BO {

	private static final Logger LOGGER = LoggerFactory.getLogger(${entityName}BO.class);

	private static ${entityName}Assembler assembler = new ${entityName}Assembler();

#foreach ( $field in $fields )
#if( ${field.isSimpleType()} )
#if( ${field.hasMinValue()} )	
	private static final ${field.javaType} ${field.uppercasedName}_MIN_VALUE = new ${field.javaType}("${field.minValue}");
#end
#if( ${field.hasMaxValue()} )
	private static final ${field.javaType} ${field.uppercasedName}_MAX_VALUE = new ${field.javaType}("${field.maxValue}");
#end
#if( ${field.hasMinLength()} )
	public static final int ${field.uppercasedName}_MIN_LENGTH = ${field.minLength};
#end
#if( ${field.hasMaxLength()} )
	public static final int ${field.uppercasedName}_MAX_LENGTH = ${field.maxLength};
#end
#if( ${field.hasScale()} )
	private static final int ${field.uppercasedName}_SCALE = ${field.scale};
#end
#if(${field.hasFormat()})
	private static final String [] ${field.uppercasedName}_VALID_PATTERNS = new String [] {${field.patterns}};
#end
#end
#end

#foreach ($validator in $entity.validators)
	private ${validator.capitalizedName} ${validator.name} = new ${validator.capitalizedName}();
#end

#foreach ( $idField in $idFields )
	private ${idField.javaType}		${idField.name};
#end
#if ($useOptimisticLocking)	 
	private Integer oplock;
#end
#foreach ( $field in $fields )
#if ($field.isEnumerationType() && $field.isExternal())
	private ${field.enumeration.columnType} ${field.name};
#else 
	private ${field.javaType}		${field.name};
#end
#end
#foreach ($relation in $relations)
	private Set		${relation.label}s;
#end
#foreach ($inverseRelation in $inverseRelations)
	private ${inverseRelation.name}BO parent${inverseRelation.name};
#end
#foreach ($reference in $references)
#if( $reference.isExternal() )
	private ${reference.type}		${reference.name};
#foreach( $fk in $reference.foreignKeyFields )
	private ${fk.javaType}			${reference.name}${fk.capitalizedName};
#end
#else
	private ${reference.type}BO		${reference.name};
#end
#end
#foreach ($composite in $composites)
	private ${composite.type}BOComposite ${composite.name}Composite;
#end

    /**
     * Returns the log instance for this class.
     * @return A {@link Logger} instance for {@link ${entityName}BO}
     */
    protected Logger getLog() {
    	return LOGGER;
    }

	/**
	 * Answer the logical entity name
	 *
	 * @return String - The logical entity name
	 */
	public String getEntityName() {
		return ${entityName}.ENTITY;
	}
	
	/**
	 * Get the values for this ${entityName} entity
	 */
	public ${entityName} get${entityName}Values() {		
		return assembler.create${entityName}((${entityName}BO)this);
	}
	
	/**
	 * Set the values for this ${entityName} entity
	 */
	public void set${entityName}Values(${entityName} entity) {
		assembler.update${entityName}BO(entity, (${entityName}BO)this);
	}

#foreach ( $idField in $idFields )

	/**
	 * Get the ${idField.label}
	 *
	 * @return The ${idField.label}
	 */
	public ${idField.javaType} get${idField.capitalizedName}() {
		return ${idField.name};
	}
	
	/**
	 * Set the ${idField.label}
	 *
	 * @param The ${idField.label}
	 */
	public void set${idField.capitalizedName}(${idField.javaType} ${idField.name}) {
#if ($idField.getJavaType().equals("String"))
		${idField.name} = StringUtils.trimToNull(${idField.name});
#end	
		this.${idField.name} = ${idField.name};
	}
#end
#if ($useOptimisticLocking)

	/**
	 * Get the optimistic locking value
	 * @return The optimistic locking value 
	 */
	public Integer getOplock() {
		return oplock;
	}
	
	/**
	 * Set the optimistic locking value
	 * @param The optimistic locking value
	 */
	void setOplock(Integer oplock) {
		this.oplock = oplock;
	}

#end
#foreach ( $composite in $composites )
	public void validate${composite.capitalizedName}() {
		get${composite.capitalizedName}Composite().fieldValidation();
	}

#end

	protected void complexValidationOnComposites() {
		super.complexValidationOnComposites();
	
#foreach ( $composite in $composites )
		get${composite.capitalizedName}Composite().complexValidation();
#end
	}

#foreach ( $field in $fields )
	/**
#if ($field.documentation)
	 * Gets: ${field.documentation}
#else
	 * Get the ${field.label}
#end
	 *
	 * @return The ${field.label}
	 */
	public ${field.javaType} get${field.capitalizedName}() {
#if ($field.isEnumerationType() && $field.isExternal())
#if ($field.enumeration.isNamed()) 
		return ${field.name} == null ? null : ${field.javaType}.getEnum(${field.name});
#else 
		return ${field.name} == null ? null : ${field.javaType}.getEnum(${field.name}.intValue());
#end
#else
		return ${field.name};
#end
	}
	
	/**
#if ($field.documentation)
	 * Sets: ${field.documentation}
#else
	 * Set the ${field.label}
#end
	 *
	 * @param The ${field.label}
	 */
	public void set${field.capitalizedName}(${field.javaType} ${field.name}) {
#if ($field.getJavaType().equals("String"))
		${field.name} = StringUtils.trimToNull(${field.name});
#end
#if ($field.isEnumerationType() && $field.isExternal())
#if ($field.enumeration.isNamed())
		this.${field.name} = ${field.name} == null ? null : ${field.name}.getName();
#else
		this.${field.name} = ${field.name} == null ? null : new Integer(${field.name}.getValue());
#end
#else	
		this.${field.name} = ${field.name};
#end
	}
	
	/**
	 * Validates ${field.label}
	 */
	protected void validate${field.capitalizedName}() {
		${field.javaType} value = get${field.capitalizedName}();
#if( ${field.isRequired()} )		
		//check requiredness:		
		if( value == null ) {
			Validations.validateRequired(value, "${field.name}", "${field.label}", getMessages());
						
			//no need to continue:
			return;
		}		
#else
		//check for a value to validate:
		if ( value == null ) {
			//nothing to validate
			return;
		}						
#end
#if( ${field.isSimpleType()} )
#if( ${field.hasMinValue()} )
		// check min value
		Validations.validateMinValue(value, ${field.uppercasedName}_MIN_VALUE, "${field.name}", "${field.label}", getMessages());
#end
#if( ${field.hasMaxValue()} )
		//check max value
		Validations.validateMaxValue(value, ${field.uppercasedName}_MAX_VALUE, "${field.name}", "${field.label}", getMessages());
#end
#if( ${field.hasMinLength()} )
		//check min length
		Validations.validateMinLength(value, ${field.uppercasedName}_MIN_LENGTH, "${field.name}", "${field.label}", getMessages());
#end
#if( ${field.hasMaxLength()} )
		//check max length
		Validations.validateMaxLength(value, ${field.uppercasedName}_MAX_LENGTH, "${field.name}", "${field.label}", getMessages());
#end
#if( ${field.hasScale()} )
		//check scale
		Validations.validateScale(value, ${field.uppercasedName}_SCALE, "${field.name}", "${field.label}", getMessages());
#end
#if (${field.hasFormat()})
		Validations.validateFormat(value, ${field.uppercasedName}_VALID_PATTERNS, "${field.name}", "${field.label}", getMessages());
#end
#elseif( ${field.isEnumerationType()} )
		
		//validate a valid enumeration value:
		String enumName = value.getName();
		Validations.validateEnumeration(value, ${field.javaType}.getEnum(enumName), "${field.name}", "${field.label}", getMessages());
#end
	}	
	
	
#end
#foreach ($composite in $composites)
	/**
	 * Get the ${composite.label} composite for this instance.
	 *
	 * @return The ${composite.label} composite
	 */
	public ${composite.type}BOComposite get${composite.capitalizedName}Composite() {
		if (${composite.name}Composite == null) {
			${composite.name}Composite = new ${composite.type}BOComposite();
		}

		return ${composite.name}Composite;
	}
#end
#foreach ($inverseRelation in $inverseRelations)

	/**
	 * Set the parent ${inverseRelation.name} onto this instance
	 * @param parent The parent instance to set
	 */
	public void set${inverseRelation.name}(${inverseRelation.name}BO parent) {
		parent${inverseRelation.name} = parent;
	}
	
	/**
	 * Returns the parent of the type for this instance
	 * @return The parent instance or null if no parent of this type exists
	 */
	public ${inverseRelation.name}BO get${inverseRelation.name}() {
		return parent${inverseRelation.name};
	}	
#end
#foreach ($relation in $relations) 

	/**
#if ($relation.documentation)
	 * Sets: ${relation.documentation}
#else
	 * Set the ${relation.label} relation
#end
	 * 
	 * @param Set - The ${relation.label}s
	 */
	public void set${relation.type}s(Set ${relation.label}s) {
		this.${relation.label}s = ${relation.label}s;
	} 

	/**
#if ($relation.documentation)
	 * Gets: ${relation.documentation}
#else
	 * Get the ${relation.label} relation
#end
	 * 
	 * @return Set - The ${relation.label}s
	 */
	public Set get${relation.type}s() {
		if( ${relation.label}s == null ) {
			${relation.label}s = new HashSet();
		}
		
		return ${relation.label}s;
	}
	 
	/**
#if ($relation.documentation)
	 * Adds: ${relation.documentation}
#else
	 * Add a ${relation.label}
#end
	 *
	 * @param The ${relation.label} to add
	 */
	public void add${relation.type}(${relation.type}BO ${relation.label}) {
		Set childSet = get${relation.type}s();
		if (childSet == null) {
			childSet = new HashSet();
			set${relation.type}s(childSet);
		}
		
		${relation.label}.set${entityName}( (${entityName}BO) this );
		childSet.add( ${relation.label} );
	}
	 
	/**
#if ($relation.documentation)
	 * Removes: ${relation.documentation}
#else
	 * Remove a ${relation.label}
#end
	 *
	 * @param The ${relation.label} to remove
	 */
	public ${relation.type}BO remove${relation.type}(${relation.type}BO ${relation.label}) {
		if( get${relation.type}s().remove( ${relation.label} ) ) {
			${relation.label}.set${entityName}(null);
			
		} else {
			getLog().error("Could not remove ${relation.label} instance with key " + ${relation.label}.getKey());
			
		}
	    
		return ${relation.label};
	}
#end
#foreach ($reference in $references)
#if( $reference.isExternal() )
#foreach( $fk in $reference.foreignKeyFields )
	
	/**
	 * Get the ${fk.name} field from the ${reference.name} external reference
	 *
	 */
	private ${fk.javaType} get${reference.capitalizedName}${fk.capitalizedName}() {
		return ${reference.name}${fk.capitalizedName};
	}
	
	/**
	 * Set the ${fk.name} field for the ${reference.name} external reference
	 *
	 */
	private void set${reference.capitalizedName}${fk.capitalizedName}(${fk.javaType} ${reference.name}${fk.capitalizedName}) {
		this.${reference.name}${fk.capitalizedName} = ${reference.name}${fk.capitalizedName};
	}
#end
	
	/**
#if ($reference.documentation)
	 * Gets: ${reference.documentation}
#else
	 * Get the ${reference.label} external reference
#end
	 *
	 * @return ${reference.type} - The ${reference.label}
	 */
	public ${reference.type} get${reference.capitalizedName}() {
	
		${reference.type}PK pk = ${reference.importPrefix}.transfer.TransferObjectFactory.create${reference.type}PK();
#foreach( $fk in $reference.foreignKeyFields )
		if (get${reference.capitalizedName}${fk.capitalizedName}() == null) {
			return null;
		}
		pk.set${fk.capitalizedName}( get${reference.capitalizedName}${fk.capitalizedName}() );
#end
	
		${reference.name} = ${reference.importPrefix}.service.delegate.ServiceDelegateFactory.createEntityMaintenanceServiceDelegate().findByPrimaryKey( pk ).get${reference.type}();
		
		return ${reference.name};
	}
	 
	/**
#if ($reference.documentation)
	 * Sets: ${reference.documentation}
#else
	 * Set the ${reference.label} reference
#end
	 *
	 * @param The ${reference.label}
	 */
	public void set${reference.capitalizedName}(${reference.type} ${reference.name}) {
		this.${reference.name} = ${reference.name};
#foreach( $fk in $reference.foreignKeyFields )
		set${reference.capitalizedName}${fk.capitalizedName}( ${reference.name}.get${fk.capitalizedName}() );
#end
	}
	
	/**
	 * Validates ${reference.label}
	 */
	protected void validate${reference.capitalizedName}() {
#if( ${reference.isRequired()} )

		if( ${reference.fkCondition} ) {
			addError( 	"${reference.name}", 
						"null.not.allowed", 
						new Object[] { "${reference.name}" } );
						
			//no need to continue:
			return;
		}		
#else
		//check for a value to validate:
		if ( ${reference.fkCondition} ) {
			//nothing to validate
			return;
		}			
#end

		if ( get${reference.capitalizedName}() == null) {
			addError( 	"${reference.name}", 
						"invalid.reference", 
						new Object[] { "${reference.name}" } );
						
		}
		
	}
	

#else 
	
	/**
	 * Get the ${reference.label} reference
	 *
	 * @return ${reference.type}BO - The ${reference.label}
	 */
	public ${reference.type}BO get${reference.capitalizedName}() {
		return ${reference.name};

	}
	 
	/**
	 * Set the ${reference.label} reference
	 *
	 * @param The ${reference.label}
	 */
	public void set${reference.capitalizedName}(${reference.type}BO ${reference.name}) {
		this.${reference.name} = ${reference.name};
	}
	
	/**
	 * Validates ${reference.label}
	 */
	protected void validate${reference.capitalizedName}() {
		${reference.type}BO ref = get${reference.capitalizedName}();
#if( ${reference.isRequired()} )		
		//check requiredness:		
		if( ref == null ) {	
			addError( 	"${reference.name}", 
						"null.not.allowed", 
						new Object[] { "${reference.name}" } );
						
			//no need to continue:
			return;
		}		
#else
		//check for a value to validate:
		if ( ref == null ) {
			//nothing to validate
			return;
		}			
#end

		//ensure that this is a valid reference instance.  First, 
		//check to see if the pk has a non-null value.  If not, then
		//try to load the reference:
		${reference.type}BO retrievedRef = null;
		boolean shouldValidate = true;		
		${reference.type}PK pk = (${reference.type}PK)ref.getKey();
		shouldValidate = (pk.getValue() != null);
		if (shouldValidate) {			
			retrievedRef = ${reference.type}BO.findByPrimaryKey(pk);
		}
		if (retrievedRef == null) {
			addError( 	"${reference.name}", 
						"invalid.reference", 
						new Object[] { "${reference.name}" } );
						
		}
		
	}	
#end
#end
#if( $parent == "null" )

	/**
	 * Save the state of the ${entityName}
	 *
	 */
	public void save() {
		validate();
		
		if( ! getAllMessages().hasErrorMessages() ) {
			normalize();
		
			${entityName}Dao dao = DaoFactory.create${entityName}Dao();
			
			Validated validValues = new Validated() {
			
				public BusinessObject getValidValues() {
					return ${entityName}BaseBO.this;
				}
			
			};
			
			dao.save${entityName}(validValues);			
		}
	}
	
	/**
	 * Delete the state of the ${entityName}
	 *
	 */
	public void delete() {
		${entityName}Dao dao = DaoFactory.create${entityName}Dao();
		dao.delete( getKey() );
	}
#end

#if ( $idFields.size() > 0 )

	/**
	 * Get the primary key for the ${entityName}
	 *
	 */
	public PrimaryKey getKey() {
		return get${entityName}PK();
	}
	
	/**
	 * Get the primary key for the ${entityName}
	 *
	 */
	public ${entityName}PK get${entityName}PK() {
		return new ${entityName}PK( ${entity.keySignatureParams} ); 
	}
	
	/**
	 * Set the key fields from the primary key
	 *
	 */
	public void setKey(PrimaryKey pk) {
		set${entityName}PK( (${entityName}PK) pk ); 
	}
	 
	/**
	 * Set the key fields from the primary key
	 *
	 */
	public void set${entityName}PK(${entityName}PK pk) {
		
#foreach ( $idField in $idFields )
		this.${idField.name} = pk.get${idField.capitalizedName}();
#end		
	}
#else

	/**
	 * Get the key field for the ${entityName}
	 *
	 */
	public PrimaryKey getKey() {
		return null;
	}
	
	/**
	 * Set the key field
	 *
	 */
	public void setKey(PrimaryKey key) {
	}
#end
	
	/**
	 * Executes all field-level validations
	 */
	protected void fieldValidation() {
		super.fieldValidation();
		
#foreach ( $field in $fields )		
		validate${field.capitalizedName}();
#end		

#if( $relations.size() > 0 )
		//call field validation on children:
#foreach ($relation in $relations)
		Set ${relation.label}Set = get${relation.type}s();
		if ((${relation.label}Set != null) && (${relation.label}Set.size() > 0)) {
			${relation.type}BO child;
			Iterator ${relation.label}Iterator = ${relation.label}Set.iterator();
			while (${relation.label}Iterator.hasNext()) {
				child = (${relation.type}BO)${relation.label}Iterator.next();
				child.fieldValidation();
			}
			
		}

#end		
#end
	}	
	
	protected void compositeValidation() {
		super.compositeValidation();

#foreach ($composite in $composites)
		validate${composite.capitalizedName}();
#end
	}
	
	/**
	 * Executes all reference-level validations
	 */
	protected void referenceValidation() {
		super.referenceValidation();
		
#foreach ( $reference in $references )		
		validate${reference.capitalizedName}();
#end
#foreach($composite in $composites)
		get${composite.capitalizedName}Composite().referenceValidation();
#end		

	}	
	
	/**
	 * Executes all complex validation on children
	 */
	protected void complexValidationOnChildren() {
		super.complexValidationOnChildren();	

#if( $relations.size() > 0 )
		//call complex validation on children:
#foreach ($relation in $relations)
		Set ${relation.label}Set = get${relation.type}s();
		if ((${relation.label}Set != null) && (${relation.label}Set.size() > 0)) {
			${relation.type}BO child;
			Iterator ${relation.label}Iterator = ${relation.label}Set.iterator();
			while (${relation.label}Iterator.hasNext()) {
				child = (${relation.type}BO)${relation.label}Iterator.next();
				child.complexValidation();
			}
			
		}

#end		
#end
#foreach($composite in $composites)
		get${composite.capitalizedName}Composite().complexValidationOnChildren();
#end
	}
	
	/**
	 * Find the ${entityName} by primary key fields
	 *
	 * @param pk The primary key for the ${entityName}
	 * @return ${entityName} The retrieved ${entityName}
	 */
	public static ${entityName}BO findByPrimaryKey(${entityName}PK pk) {
		${entityName}Dao dao = DaoFactory.create${entityName}Dao();
		return dao.findByPrimaryKey( pk );
	}	
		
#foreach( $query in $queries )	

	/**
#if ($query.documentation)
	 * ${query.documentation}
#else
	 * Execute the ${query.name} query
#end
	 *
#foreach( $criterion in $query.criteria )
#if ($criterion.documentation)
	 * @param ${criterion.name} ${criterion.documentation}
#else
	 * @param ${criterion.name} The ${criterion.name}
#end
#end
	 * @return List of ${entityName}s
	 */	 
#set( $numCriteria = $query.criteria.size() ) 
#set( $currentNum  = 0 )
	public static List ${query.lowercaseName}(#foreach( $criterion in $query.criteria )${criterion.javaType} ${criterion.name} #set($currentNum = $currentNum+1)#if($currentNum<$numCriteria), #end#end) {
#set( $numCriteria = $query.criteria.size() ) 
#set( $currentNum  = 0 )
		List bos = DaoFactory.create${entityName}Dao().${query.lowercaseName}(#foreach( $criterion in $query.criteria )${criterion.name} #set($currentNum = $currentNum+1)#if($currentNum<$numCriteria), #end#end);
		return bos;
	}
#end

#if ($inverseRelations.size() == 0)
	public Messages getAllMessages() {
		MessagesSet set = new MessagesSet();
		gatherMessages(set);
		return set;
	}
#else
	public Messages getAllMessages() {
#foreach ($inverseRelation in $inverseRelations)
		Messages allMessages = null;
		if (parent${inverseRelation.name} != null) {
			allMessages = parent${inverseRelation.name}.getAllMessages();
			
		} else {
			MessagesSet set = new MessagesSet();
			gatherMessages(set);
			allMessages = set;
			
		}
		
		return allMessages;
#end
	}
#end

	protected void gatherMessages(MessagesSet set) {
		set.addMessages(getMessages());
		
#foreach ($composite in $composites)
		set.addMessages(get${composite.capitalizedName}Composite().getAllMessages());
#end
		
#foreach ($relation in $relations)

		Set	${relation.label}Set = get${relation.type}s();
		if ((${relation.label}Set != null) && (${relation.label}Set.size() > 0)) {
			Iterator ${relation.label}SetIterator = ${relation.label}Set.iterator();
			while (${relation.label}SetIterator.hasNext()) {
				${relation.type}BO child = (${relation.type}BO) ${relation.label}SetIterator.next();
				child.gatherMessages(set);
			}
		}
#end
	}

	public boolean equals(Object o) {
		boolean areEqual = false;
		
		try {
			${entityName}BO bo = (${entityName}BO) o;
			// Can't be null!
			PrimaryKey thisPk = getKey();
			PrimaryKey thatPk = (bo == null) ? null : bo.getKey();
			if (thatPk != null && thisPk.getValue() == null && thatPk.getValue() == null) {
				return this == o;
			}
			if (thisPk == thatPk || (thisPk.equals(thatPk))) {
				areEqual = true;
			}
		} catch (ClassCastException ex) {
			areEqual = false;
		}
		
		return areEqual;
	}
	
	public int hashCode() {
		// Use the Messages as a last resort when there is no primary key value.
		// The messages field is the only field on this object that is guaranteed to
		// be not null and the same instance for the life of the object.
		return (getKey().getValue() == null) ? getMessages().hashCode() : getKey().getValue().hashCode();
	}

}