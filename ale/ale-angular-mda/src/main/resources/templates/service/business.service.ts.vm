import { Injectable } from '@angular/core';
import { FermenterResponse } from '../../../shared/model/fermenter-response.model';
import { GlobalErrorHandler } from '../../../shared/global-error-handler.service';
import { Constants } from '../../../constants';
import { HttpClient, HttpParams } from '@angular/common/http';
import { map, catchError } from 'rxjs/operators';
import { Observable } from 'rxjs';
import { BusinessError } from '../../../generated/business-error.model';

#foreach( $import in $service.imports )
#if( !$import.isEnumeration() )
import { ${import.type} } from '../../../shared/model/${import.typeLowerHyphen}.model';
#end## end if enum
#end## end for imports

/*******************************************************
 * Business services for ${service.name}Service
 *
 * Generated Code - DO NOT MODIFY
 * Template = business.service.ts.vm
 *******************************************************/
@Injectable({
  providedIn: 'root'
})
export class ${service.name}Service {

    protected constants = new Constants();

    // make sure that the ${service.artifactIdUpperUnderscore}_END_POINT is
    //    defined in the constants.ts file so that we know where the rest service is located
    protected ${service.name}ServiceURL =
      this.constants.${service.artifactIdUpperUnderscore}_END_POINT + '/${service.name}Service';

    constructor(
      protected http: HttpClient,
      protected errorHandler: GlobalErrorHandler
      ) {}

#foreach( $operation in $service.angularOperations )
#if( !$operation.usesEnumerations() && !$operation.usesPaging() )## pending support for enums and paging
#if($operation.transactionAttribute == "Supports")
##
## Get calls
##
##
    /**
    * Call the ${operation.nameLowerCamel} operation on ${service.name}Service
    * ${operation.documentation}
    */
#if( $operation.return.type == 'void' )
## void responses return a fermenter response so we have something to return
#if( $operation.parameters.isEmpty() )
    public ${operation.nameLowerCamel}(skipGlobalErrorHandler = false): Observable<FermenterResponse<${operation.return.signature}>> {
#else
    public ${operation.nameLowerCamel}(${operation.getSignatureParametersForAngular()}, skipGlobalErrorHandler = false): Observable<FermenterResponse<${operation.return.signature}>> {
#end## end of if there are multiple params
#else
## non void responses return the item we are trying to get
## we don't return the fermenter response as we don't expect any fermenter messages for get calls
## if there is a fermenter error message then it will call the global error handler to handle the exception
#if( $operation.parameters.isEmpty() )
    public ${operation.nameLowerCamel}(skipGlobalErrorHandler = false): Observable<${operation.return.signature}> {
#else
    public ${operation.nameLowerCamel}(${operation.getSignatureParametersForAngular()}, skipGlobalErrorHandler = false): Observable<${operation.return.signature}> {
#end## end of if there are multiple params
#end## end of if return is void
##
##
##
##
        const url = this.${service.name}ServiceURL + '/${operation.nameLowerCamel}' ;
#if( !$operation.parameters.isEmpty() )

        let params = new HttpParams();
#foreach( $param in $operation.parameters)
#if($param.ismany())
        for(const ${param.name} of ${param.name}s) {
            params = params.set('${param.name}', String(${param.name}));
        }
#else
        params = params.set('${param.name}', String(${param.name}));
#end## end of if is many
#end## end of for loop

        return this.http.get<FermenterResponse<${operation.return.signature}>>(url, {params}).pipe(
#else## else for if params is empty

        return this.http.get<FermenterResponse<${operation.return.signature}>>(url).pipe(
#end## end for if params is empty
            map((response: FermenterResponse<${operation.return.signature}>) => {
                const fermenterResponse = new FermenterResponse<${operation.return.signature}>(response);
                this.checkFermenterResponseIsInitialized(fermenterResponse);

#if( $operation.return.isBaseType() && $operation.return.angularTypeBase != 'Date')
#if( !$operation.return.isMany() )
                fermenterResponse.value = response.value;
#else
                if (response.value) {
                    fermenterResponse.value = new Array<${operation.return.angularType}>();
                    for (const element of response.value) {
                        fermenterResponse.value.push(element);
                    }
                }
#end## end of isMany
#else
#if( !$operation.return.isMany() )
                if (response.value) {
                    fermenterResponse.value = new ${operation.return.angularType}(response.value);
                }
#else
                if (response.value) {
                    fermenterResponse.value = new Array<${operation.return.angularType}>();
                    for (const element of response.value) {
                        fermenterResponse.value.push(new ${operation.return.angularType}(element));
                    }
                }
#end## end of isMany
#end## end for if isBaseType()

                if (fermenterResponse.messages.hasErrorMessages() && !skipGlobalErrorHandler) {
                    throw new BusinessError(fermenterResponse.messages);
                }
#if( $operation.return.type == 'void' )
                return fermenterResponse;
#else
                return fermenterResponse.value;
#end## end of return type void
            }),
            catchError(error => this.errorHandler.handleServiceCallError(error))
        );
    }
#else
##
## Post calls
##
##
    /**
    * Call the ${operation.nameLowerCamel} operation on ${service.name}Service
    * ${operation.documentation}
    */
#if( $operation.parameters.isEmpty() )
    public ${operation.nameLowerCamel}(skipGlobalErrorHandler = false):
                Observable<FermenterResponse<${operation.return.signature}>> {
#else
    public ${operation.nameLowerCamel}(${operation.getSignatureParametersForAngular()}, skipGlobalErrorHandler = false):
                Observable<FermenterResponse<${operation.return.signature}>> {
#end## end of if there are multiple params
        const url = this.${service.name}ServiceURL + '/${operation.nameLowerCamel}' ;

#if( $operation.hasUrlParams() )
        let params = new HttpParams();
#foreach( $param in $operation.angularParameters)
#if( !$param.isEntity() )
## for post calls entities are passed in the body, other params are query params
#if( $param.ismany() )
        for(const ${param.name} of ${param.name}s) {
            params = params.set('${param.name}', String(${param.name}));
        }
#else## else for if is many
        params = params.set('${param.name}', String(${param.name}));
#end## end of if is many
#end## end of if is entity
#end## end of for param loop

        return this.http.post<FermenterResponse<${operation.return.signature}>>(url, ${operation.postBodyParameterName}, {params}).pipe(
#else## else for if params is empty
        return this.http.post<FermenterResponse<${operation.return.signature}>>(url, ${operation.postBodyParameterName}).pipe(
#end## end for if params is empty
            map((response: FermenterResponse<${operation.return.signature}>) => {
                const fermenterResponse = new FermenterResponse<${operation.return.signature}>(response);
                this.checkFermenterResponseIsInitialized(fermenterResponse);

#if( $operation.return.isBaseType() && $operation.return.angularTypeBase != 'Date')
#if( !$operation.return.isMany() )
                fermenterResponse.value = response.value;
#else
                if (response.value) {
                    fermenterResponse.value = new Array<${operation.return.angularType}>();
                    for (const element of response.value) {
                        fermenterResponse.value.push(element);
                    }
                }
#end## end of isMany
#else
#if( !$operation.return.isMany() )
                if (response.value) {
                    fermenterResponse.value = new ${operation.return.angularType}(response.value);
                }
#else
                if (response.value) {
                    fermenterResponse.value = new Array<${operation.return.angularType}>();
                    for (const element of response.value) {
                        fermenterResponse.value.push(new ${operation.return.angularType}(element));
                    }
                }
#end## end of isMany
#end## end for if isBaseType()

                if (fermenterResponse.messages.hasErrorMessages() && !skipGlobalErrorHandler) {
                    throw new BusinessError(fermenterResponse.messages);
                }
                return fermenterResponse;
            }),
            catchError(error => this.errorHandler.handleServiceCallError(error))
        );
    }
#end## end of post vs get if block
#else
    /**
    * ${operation.nameLowerCamel} is not implemeneted because support for enums and paging is pending
    */
    public ${operation.nameLowerCamel}_PENDING(NOT_SUPPORTED: string) {
        throw new Error('${operation.nameLowerCamel} is not implemeneted because support for enums and paging is pending');
    }
#end## end of if usesEnumerations
#end## end of for operation

    protected checkFermenterResponseIsInitialized(fermenterResponse: FermenterResponse<{}>) {
        if (!fermenterResponse) {
            const msg = 'Failed to initialize fermenter response for service call.';
            this.errorHandler.handleServiceCallError(msg);
            throw new Error(msg);
        }
    }
}
