package ${prefix}.bizobj;

import ${prefix}.persist.*;
import ${prefix}.transfer.*;

import org.tigris.atlas.transfer.PrimaryKey;
import org.tigris.atlas.transfer.TransferObject;
import org.tigris.atlas.bizobj.*;
#if( $references.size() > 0 )
import org.tigris.atlas.persist.*;
#end
import org.tigris.atlas.validate.Validations;

import org.tigris.atlas.messages.MessageManager;
import org.tigris.atlas.messages.Messages;
import org.tigris.atlas.messages.MessageUtils;

import java.util.UUID;

#if( $relations.size() > 0 )
import java.util.Set;
import java.util.HashSet;
import java.util.Iterator;
#end
#if( $queries.size() > 0 )
import java.util.List;
#foreach($query in $queries)
#foreach($criteria in $query.criteria)
import ${criteria.import};
#end
#end
#end

#foreach( $reference in $references ) 
#if( $reference.isExternal() )
import ${reference.importPrefix}.transfer.${reference.type};
import ${reference.importPrefix}.transfer.${reference.type}PK;
#end
#end

#foreach ($import in $imports )
import ${import};
#end

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import org.apache.commons.lang3.StringUtils;

#foreach ($validator in $entity.validators)
import ${validator.import};
#end

/**
 * Business object for the ${entityName} application entity.
#if ($entity.documentation)
 * ${entity.documentation}
#end
 *
 * Generated Code - DO NOT MODIFY
 */
public abstract class ${entityName}BaseBO extends ${extends}BO {

	private static final Logger LOGGER = LoggerFactory.getLogger(${entityName}BO.class);

	/**
	 * Transient ID that is not persistent but guaranteed to be non-null during an object's lifecycle
	 * and thereby usable in hashCode() and equals() methods as a fallback for scenarios where an entity
	 * may not have a non-null {@link PrimaryKey} value.
	 */
	protected final UUID internalTransientID = UUID.randomUUID();
		
	private static final ${entityName}Dao DAO = DaoFactory.create${entityName}Dao();

#foreach ( $field in $fields )
#if( ${field.isSimpleType()} )
#if( ${field.hasMinValue()} )	
	private static final ${field.javaType} ${field.uppercasedName}_MIN_VALUE = new ${field.javaType}("${field.minValue}");
#end
#if( ${field.hasMaxValue()} )
	private static final ${field.javaType} ${field.uppercasedName}_MAX_VALUE = new ${field.javaType}("${field.maxValue}");
#end
#if( ${field.hasMinLength()} )
	public static final int ${field.uppercasedName}_MIN_LENGTH = ${field.minLength};
#end
#if( ${field.hasMaxLength()} )
	public static final int ${field.uppercasedName}_MAX_LENGTH = ${field.maxLength};
#end
#if( ${field.hasScale()} )
	private static final int ${field.uppercasedName}_SCALE = ${field.scale};
#end
#if(${field.hasFormat()})
	private static final String [] ${field.uppercasedName}_VALID_PATTERNS = new String [] {${field.patterns}};
#end
#end
#end

#foreach ($validator in $entity.validators)
	private ${validator.capitalizedName} ${validator.name} = new ${validator.capitalizedName}();
#end

#foreach ( $idField in $idFields )
	private ${idField.javaType}	${idField.name};
#end
#if ($useOptimisticLocking)	 
	private Integer oplock;
#end
#foreach ( $field in $fields )
#if ($field.isEnumerationType() && $field.isExternal())
	private ${field.enumeration.columnType} ${field.name};
#else 
	private ${field.javaType} ${field.name};
#end
#end
#foreach ($relation in $relations)
	private Set<${relation.type}BO> ${relation.label}s;
#end
#foreach ($inverseRelation in $inverseRelations)
	private ${inverseRelation.name}BO parent${inverseRelation.name};
#end
#foreach ($reference in $references)
#if( $reference.isExternal() )
	private ${reference.type} ${reference.name};
#foreach( $fk in $reference.foreignKeyFields )
	private ${fk.javaType}			${reference.name}${fk.capitalizedName};
#end
#else
	private ${reference.type}BO ${reference.name};
#end
#end
#foreach ($composite in $composites)
	private ${composite.type}BOComposite ${composite.name}Composite;
#end

    /**
     * {@inheritDoc}
     */
    protected Logger getLogger() {
    	return LOGGER;
    }
	
	/**
	 * Get the values for this ${entityName} entity.
	 */
	public ${entityName} get${entityName}Values() {		
		return ${entityName}Assembler.create${entityName}((${entityName}BO)this);
	}
	
	/**
	 * Set the values for this ${entityName} entity.
	 */
	public void set${entityName}Values(${entityName} entity) {
#foreach ($inverseRelation in $inverseRelations)
		//make sure to keep the parent relationship instances straight:
		${inverseRelation.name}BO originalParent${inverseRelation.name} = parent${inverseRelation.name};
#end
		${entityName}Assembler.merge${entityName}BO(entity, (${entityName}BO)this);
#foreach ($inverseRelation in $inverseRelations)		
		parent${inverseRelation.name} = originalParent${inverseRelation.name};
#end		
	}

#foreach ( $idField in $idFields )

	/**
	 * Get the ${idField.label}
	 *
	 * @return The ${idField.label}
	 */
	protected ${idField.javaType} get${idField.capitalizedName}() {
		return ${idField.name};
	}
	
	/**
	 * Set the ${idField.label}
	 *
	 * @param The ${idField.label}
	 */
	protected void set${idField.capitalizedName}(${idField.javaType} ${idField.name}) {
#if ($idField.getJavaType().equals("String"))
		${idField.name} = StringUtils.trimToNull(${idField.name});
#end	
		this.${idField.name} = ${idField.name};
	}
#end
#if ($useOptimisticLocking)

	/**
	 * Get the optimistic locking value
	 * @return The optimistic locking value 
	 */
	public Integer getOplock() {
		return oplock;
	}
	
	/**
	 * Set the optimistic locking value
	 * @param The optimistic locking value
	 */
	void setOplock(Integer oplock) {
		this.oplock = oplock;
	}

#end
#foreach ( $composite in $composites )
	public void validate${composite.capitalizedName}() {
		get${composite.capitalizedName}Composite().fieldValidation();
	}

#end

	@Override
	protected void complexValidationOnComposites() {
#foreach ( $composite in $composites )
		get${composite.capitalizedName}Composite().complexValidation();
#end
	}

#foreach ( $field in $fields )
	/**
#if ($field.documentation)
	 * Gets: ${field.documentation}
#else
	 * Get the ${field.label}
#end
	 *
	 * @return The ${field.label}
	 */
	public ${field.javaType} get${field.capitalizedName}() {
#if ($field.isEnumerationType() && $field.isExternal())
#if ($field.enumeration.isNamed()) 
		return ${field.name} == null ? null : ${field.javaType}.getEnum(${field.name});
#else 
		return ${field.name} == null ? null : ${field.javaType}.getEnum(${field.name}.intValue());
#end
#else
		return ${field.name};
#end
	}
	
	/**
#if ($field.documentation)
	 * Sets: ${field.documentation}
#else
	 * Set the ${field.label}
#end
	 *
	 * @param The ${field.label}
	 */
	public void set${field.capitalizedName}(${field.javaType} ${field.name}) {
#if ($field.getJavaType().equals("String"))
		${field.name} = StringUtils.trimToNull(${field.name});
#end
#if ($field.isEnumerationType() && $field.isExternal())
#if ($field.enumeration.isNamed())
		this.${field.name} = ${field.name} == null ? null : ${field.name}.getName();
#else
		this.${field.name} = ${field.name} == null ? null : new Integer(${field.name}.getValue());
#end
#else	
		this.${field.name} = ${field.name};
#end
	}
	
	/**
	 * Validates ${field.label}
	 */
	protected void validate${field.capitalizedName}() {
		${field.javaType} value = get${field.capitalizedName}();
#if( ${field.isRequired()} )		
		//check requiredness:		
		if( value == null ) {
			Validations.validateRequired(value, "${entity.name}.${field.name}", "${field.label}", MessageManager.getMessages());
						
			//no need to continue:
			return;
		}		
#else
		//check for a value to validate:
		if ( value == null ) {
			//nothing to validate
			return;
		}						
#end
#if( ${field.isSimpleType()} )
#if( ${field.hasMinValue()} )
		// check min value
		Validations.validateMinValue(value, ${field.uppercasedName}_MIN_VALUE, "${entity.name}.${field.name}", "${field.label}", MessageManager.getMessages());
#end
#if( ${field.hasMaxValue()} )
		//check max value
		Validations.validateMaxValue(value, ${field.uppercasedName}_MAX_VALUE, "${entity.name}.${field.name}", "${field.label}", MessageManager.getMessages());
#end
#if( ${field.hasMinLength()} )
		//check min length
		Validations.validateMinLength(value, ${field.uppercasedName}_MIN_LENGTH, "${entity.name}.${field.name}", "${field.label}", MessageManager.getMessages());
#end
#if( ${field.hasMaxLength()} )
		//check max length
		Validations.validateMaxLength(value, ${field.uppercasedName}_MAX_LENGTH, "${entity.name}.${field.name}", "${field.label}", MessageManager.getMessages());
#end
#if( ${field.hasScale()} )
		//check scale
		Validations.validateScale(value, ${field.uppercasedName}_SCALE, "${entity.name}.${field.name}", "${field.label}", MessageManager.getMessages());
#end
#if (${field.hasFormat()})
		Validations.validateFormat(value, ${field.uppercasedName}_VALID_PATTERNS, "${entity.name}.${field.name}", "${field.label}", MessageManager.getMessages());
#end
#end
	}	
	
	
#end
#foreach ($composite in $composites)
	/**
	 * Get the ${composite.label} composite for this instance.
	 *
	 * @return The ${composite.label} composite
	 */
	public ${composite.type}BOComposite get${composite.capitalizedName}Composite() {
		if (${composite.name}Composite == null) {
			${composite.name}Composite = new ${composite.type}BOComposite();
		}

		return ${composite.name}Composite;
	}
#end
#foreach ($inverseRelation in $inverseRelations)

	/**
	 * Set the parent ${inverseRelation.name} onto this instance
	 * @param parent The parent instance to set
	 */
	public void set${inverseRelation.name}(${inverseRelation.name}BO parent) {
		parent${inverseRelation.name} = parent;
	}
	
	/**
	 * Returns the parent of the type for this instance
	 * @return The parent instance or null if no parent of this type exists
	 */
	public ${inverseRelation.name}BO get${inverseRelation.name}() {
		return parent${inverseRelation.name};
	}	
#end
#foreach ($relation in $relations) 

	/**
#if ($relation.documentation)
	 * Sets: ${relation.documentation}
#else
	 * Set the ${relation.label} relation.
#end
	 * 
	 * @param Set - The ${relation.label}s
	 */
	public void set${relation.type}s(Set<${relation.type}BO> ${relation.label}s) {
		this.${relation.label}s = ${relation.label}s;
	} 

	/**
#if ($relation.documentation)
	 * Gets: ${relation.documentation}
#else
	 * Get the ${relation.label} relation.
#end
	 * 
	 * @return Set - The ${relation.label}s
	 */
	public Set<${relation.type}BO> get${relation.type}s() {
		if( ${relation.label}s == null ) {
			${relation.label}s = new HashSet();
		}
		
		return ${relation.label}s;
	}
	 
	/**
#if ($relation.documentation)
	 * Adds: ${relation.documentation}
#else
	 * Add a ${relation.label}
#end
	 *
	 * @param The ${relation.label} to add
	 */
	public void add${relation.type}(${relation.type}BO ${relation.label}) {
		Set<${relation.type}BO> childSet = get${relation.type}s();
		if (childSet == null) {
			childSet = new HashSet();
			set${relation.type}s(childSet);
		}
		
		${relation.label}.set${entityName}( (${entityName}BO) this );
		childSet.add( ${relation.label} );
	}
	 
	/**
#if ($relation.documentation)
	 * Removes: ${relation.documentation}
#else
	 * Remove a ${relation.label}
#end
	 *
	 * @param The ${relation.label} to remove
	 */
	public ${relation.type}BO remove${relation.type}(${relation.type}BO ${relation.label}) {
		if( get${relation.type}s().remove( ${relation.label} ) ) {
			${relation.label}.set${entityName}(null);
			
		} else {
			getLogger().error("Could not remove ${relation.label} instance with key " + ${relation.label}.getKey());
			
		}
	    
		return ${relation.label};
	}
#end
#foreach ($reference in $references)
#if( $reference.isExternal() )
#foreach( $fk in $reference.foreignKeyFields )
	
	/**
	 * Get the ${fk.name} field from the ${reference.name} external reference
	 *
	 */
	private ${fk.javaType} get${reference.capitalizedName}${fk.capitalizedName}() {
		return ${reference.name}${fk.capitalizedName};
	}
	
	/**
	 * Set the ${fk.name} field for the ${reference.name} external reference
	 *
	 */
	private void set${reference.capitalizedName}${fk.capitalizedName}(${fk.javaType} ${reference.name}${fk.capitalizedName}) {
		this.${reference.name}${fk.capitalizedName} = ${reference.name}${fk.capitalizedName};
	}
#end
	
	/**
#if ($reference.documentation)
	 * Gets: ${reference.documentation}
#else
	 * Get the ${reference.label} external reference
#end
	 *
	 * @return ${reference.type} - The ${reference.label}
	 */
	public ${reference.type} get${reference.capitalizedName}() {
	
		${reference.type}PK pk = ${reference.importPrefix}.transfer.TransferObjectFactory.create${reference.type}PK();
#foreach( $fk in $reference.foreignKeyFields )
		if (get${reference.capitalizedName}${fk.capitalizedName}() == null) {
			return null;
		}
		pk.set${fk.capitalizedName}( get${reference.capitalizedName}${fk.capitalizedName}() );
#end
	
		${reference.name} = ${reference.importPrefix}.service.delegate.ServiceDelegateFactory.createEntityMaintenanceServiceDelegate().findByPrimaryKey( pk ).get${reference.type}();
		
		return ${reference.name};
	}
	 
	/**
#if ($reference.documentation)
	 * Sets: ${reference.documentation}
#else
	 * Set the ${reference.label} reference
#end
	 *
	 * @param The ${reference.label}
	 */
	public void set${reference.capitalizedName}(${reference.type} ${reference.name}) {
		this.${reference.name} = ${reference.name};
#foreach( $fk in $reference.foreignKeyFields )
		set${reference.capitalizedName}${fk.capitalizedName}( ${reference.name}.get${fk.capitalizedName}() );
#end
	}
	
	/**
	 * Validates ${reference.label}
	 */
	protected void validate${reference.capitalizedName}() {
#if( ${reference.isRequired()} )
		if( ${reference.fkCondition} ) {
			MessageManager.addMessage(MessageUtils.createErrorMessage( "null.not.allowed",
			         	new String[] { "${reference.type}.${reference.name}" }, new Object[] { "${reference.name}" } ));
						
			//no need to continue:
			return;
		}		
#else
		//check for a value to validate:
		if ( ${reference.fkCondition} ) {
			//nothing to validate
			return;
		}			
#end

		if ( get${reference.capitalizedName}() == null) {
			MessageManager.addMessage(MessageUtils.createErrorMessage( "invalid.reference",
			         	new String[] { "${reference.type}.${reference.name}" }, new Object[] { "${reference.name}" } ));
		}
		
	}
	

#else 
	
	/**
	 * Get the ${reference.label} reference
	 *
	 * @return ${reference.type}BO - The ${reference.label}
	 */
	public ${reference.type}BO get${reference.capitalizedName}() {
		return ${reference.name};

	}
	 
	/**
	 * Set the ${reference.label} reference
	 *
	 * @param The ${reference.label}
	 */
	public void set${reference.capitalizedName}(${reference.type}BO ${reference.name}) {
		this.${reference.name} = ${reference.name};
	}
	
	/**
	 * Validates ${reference.label}
	 */
	protected void validate${reference.capitalizedName}() {
		${reference.type}BO ref = get${reference.capitalizedName}();
#if( ${reference.isRequired()} )		
		//check requiredness:		
		if( ref == null ) {	
			MessageManager.addMessage(MessageUtils.createErrorMessage( "null.not.allowed",
			         	new String[] { "${reference.type}.${reference.name}" }, new Object[] { "${reference.name}" } ));
						
			//no need to continue:
			return;
		}		
#else
		//check for a value to validate:
		if ( ref == null ) {
			//nothing to validate
			return;
		}			
#end

		//ensure that this is a valid reference instance.  First, 
		//check to see if the pk has a non-null value.  If not, then
		//try to load the reference:
		${reference.type}BO retrievedRef = null;
		boolean shouldValidate = true;		
		${reference.type}PK pk = (${reference.type}PK)ref.getKey();
		shouldValidate = (pk.getValue() != null);
		if (shouldValidate) {			
			retrievedRef = ${reference.type}BO.findByPrimaryKey(pk);
		}
		if (retrievedRef == null) {
			MessageManager.addMessage(MessageUtils.createErrorMessage( "invalid.reference",
			         	new String[] { "${reference.type}.${reference.name}" }, new Object[] { "${reference.name}" } ));
						
		}
		
	}	
#end
#end


#if ( $idFields.size() > 0 )

	/**
	 * Get the primary key for the ${entityName}
	 *
	 */
	public PrimaryKey getKey() {
		return get${entityName}PK();
	}
	
	/**
	 * Get the primary key for the ${entityName}
	 *
	 */
	public ${entityName}PK get${entityName}PK() {
		return new ${entityName}PK( ${entity.keySignatureParams} ); 
	}
	
	/**
	 * Set the key fields from the primary key
	 *
	 */
	public void setKey(PrimaryKey pk) {
		set${entityName}PK( (${entityName}PK) pk ); 
	}
	 
	/**
	 * Set the key fields from the primary key
	 *
	 */
	public void set${entityName}PK(${entityName}PK pk) {
		
#foreach ( $idField in $idFields )
		this.${idField.name} = pk.get${idField.capitalizedName}();
#end		
	}
#else

	/**
	 * Get the key field for the ${entityName}
	 *
	 */
	public PrimaryKey getKey() {
		return null;
	}
	
	/**
	 * Set the key field
	 *
	 */
	public void setKey(PrimaryKey key) {
	}
#end
	
	/**
	 * Executes all field-level validations
	 */
	@Override 
	protected void fieldValidation() {
#foreach ( $field in $fields )		
		validate${field.capitalizedName}();
#end		

#if( $relations.size() > 0 )
		//call field validation on children:
#foreach ($relation in $relations)
		Set<${relation.type}BO> ${relation.label}Set = get${relation.type}s();
		if (${relation.label}Set != null && !${relation.label}Set.isEmpty()) {
			for (${relation.type}BO child : ${relation.label}Set) {
				child.fieldValidation();
			}
		}

#end		
#end
	}	
	
	@Override 
	protected void compositeValidation() {
#foreach ($composite in $composites)
		validate${composite.capitalizedName}();
#end
	}
	
	/**
	 * Executes all reference-level validations
	 */
	@Override 
	protected void referenceValidation() {
#foreach ( $reference in $references )		
		validate${reference.capitalizedName}();
#end
#foreach($composite in $composites)
		get${composite.capitalizedName}Composite().referenceValidation();
#end		

	}	
	
	/**
	 * Executes all complex validation on children
	 */
	@Override 
	protected void complexValidationOnChildren() {
#if( $relations.size() > 0 )
		//call complex validation on children:
#foreach ($relation in $relations)
		Set<${relation.type}BO> ${relation.label}Set = get${relation.type}s();
		if (${relation.label}Set != null && !${relation.label}Set.isEmpty()) {
			for (${relation.type}BO child : ${relation.label}Set) {
				child.validate();
			}
		}

#end		
#end
#foreach($composite in $composites)
		get${composite.capitalizedName}Composite().complexValidationOnChildren();
#end
	}
	
	/**
     * {@inheritDoc}
     */
    @Override
    protected ${entity.name}Dao getDao() {
    	return ${entity.name}BO.getDefaultDao();
    }
     
	protected static ${entity.name}Dao getDefaultDao() {
		return DAO;
	}
	
	/**
	 * Find the ${entityName} by primary key fields.
	 *
	 * @param pk The primary key for the ${entityName}
	 * @return ${entityName} The retrieved ${entityName}
	 */
	public static ${entityName}BO findByPrimaryKey(${entityName}PK pk) {
		return ${entity.name}BO.getDefaultDao().findByPrimaryKey(pk);
	}	
		
#foreach( $query in $queries )	

	/**
#if ($query.documentation)
	 * ${query.documentation}
#else
	 * Execute the ${query.name} query
#end
	 *
#foreach( $criterion in $query.criteria )
#if ($criterion.documentation)
	 * @param ${criterion.name} ${criterion.documentation}
#else
	 * @param ${criterion.name} The ${criterion.name}
#end
#end
	 * @return List of ${entityName}s
	 */	 
#set( $numCriteria = $query.criteria.size() ) 
#set( $currentNum  = 0 )
	public static List<${entityName}BO> ${query.lowercaseName}(#foreach( $criterion in $query.criteria )${criterion.javaType} ${criterion.name} #set($currentNum = $currentNum+1)#if($currentNum<$numCriteria), #end#end) {
#set( $numCriteria = $query.criteria.size() ) 
#set( $currentNum  = 0 )
		List<${entityName}BO> bos = ${entity.name}BO.getDefaultDao().${query.lowercaseName}(#foreach( $criterion in $query.criteria )${criterion.name} #set($currentNum = $currentNum+1)#if($currentNum<$numCriteria), #end#end);
		return bos;
	}
#end 

	public boolean equals(Object o) {
		boolean areEqual = false;
		
		try {
			${entityName}BO bo = (${entityName}BO) o;
			// Can't be null!
			PrimaryKey thisPk = getKey();
			PrimaryKey thatPk = (bo == null) ? null : bo.getKey();
			if (thatPk != null && thisPk.getValue() == null && thatPk.getValue() == null) {
				return this.internalTransientID == bo.internalTransientID;
			}
			if (thisPk == thatPk || (thisPk.equals(thatPk))) {
				areEqual = true;
			}
		} catch (ClassCastException ex) {
			areEqual = false;
		}
		
		return areEqual;
	}
	
	public int hashCode() {
		return (getKey().getValue() == null) ? internalTransientID.hashCode() : getKey().getValue().hashCode();
	}

}